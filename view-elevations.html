<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>360° Elevation + Junction Detail</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #f5f5f0;
    color: #333;
    min-height: 100vh;
  }
  header {
    background: #2c3e50;
    color: white;
    padding: 16px 24px;
    text-align: center;
  }
  header h1 { font-size: 1.4em; font-weight: 600; letter-spacing: 0.02em; }
  header p { font-size: 0.85em; opacity: 0.7; margin-top: 4px; }

  .canvas-row {
    display: flex;
    gap: 12px;
    padding: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }
  .canvas-wrap {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    padding: 8px;
    flex: 1 1 500px;
    max-width: 900px;
    min-width: 320px;
  }
  canvas {
    width: 100%;
    height: auto;
    display: block;
    cursor: crosshair;
  }

  .controls {
    max-width: 900px;
    margin: 0 auto;
    padding: 0 16px 8px;
  }
  .slider-row {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
  }
  .slider-row label {
    font-weight: 600;
    font-size: 0.95em;
    white-space: nowrap;
  }
  .slider-row input[type=range] {
    flex: 1;
    accent-color: #2c3e50;
    height: 6px;
  }
  .slider-row .value {
    font-weight: 700;
    font-size: 1.1em;
    min-width: 90px;
    text-align: right;
    color: #c0392b;
  }

  .summary {
    max-width: 1420px;
    margin: 8px auto;
    padding: 0 16px;
  }
  .summary-grid {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    padding: 12px 20px;
    justify-content: center;
  }
  .summary-item {
    text-align: center;
    min-width: 100px;
  }
  .summary-item .label { font-size: 0.75em; color: #888; text-transform: uppercase; letter-spacing: 0.05em; }
  .summary-item .val { font-size: 1.3em; font-weight: 700; color: #2c3e50; }

  @media (max-width: 768px) {
    .canvas-row { flex-direction: column; align-items: center; padding: 8px; gap: 8px; }
    .canvas-wrap { max-width: 100%; flex: 0 0 auto; }
    header h1 { font-size: 1.1em; }
    header { padding: 10px 16px; }
    .controls { padding: 0 8px 4px; }
    .summary { padding: 0 8px; }
    .summary-grid { padding: 8px 12px; gap: 8px; }
    .summary-item .val { font-size: 1.1em; }
  }
  @media print {
    header { background: white; color: black; }
    .controls { display: none; }
    .canvas-wrap { box-shadow: none; border: 1px solid #ccc; }
    body { background: white; }
  }
</style>
</head>
<body>

<header>
  <h1>360&deg; Elevation + Junction Detail</h1>
  <p>Rotate the viewing angle to see the dome with wings from any direction</p>
</header>

<div class="controls">
  <div class="slider-row">
    <label for="pitch-slider">Roof Pitch:</label>
    <input type="range" id="pitch-slider" min="20" max="35" step="0.5" value="20">
    <span class="value" id="pitch-value">20.0&deg;</span>
  </div>
  <div class="slider-row" style="margin-top: 8px;">
    <label for="angle-slider">View Angle:</label>
    <input type="range" id="angle-slider" min="0" max="360" step="1" value="0">
    <span class="value" id="angle-value">S 0&deg;</span>
  </div>
</div>

<div class="canvas-row">
  <div class="canvas-wrap">
    <canvas id="front-elevation" width="1400" height="900"></canvas>
  </div>
  <div class="canvas-wrap">
    <canvas id="solid-elevation" width="1400" height="900"></canvas>
  </div>
</div>
<div class="canvas-row" style="justify-content: center;">
  <div class="canvas-wrap" style="max-width: 700px;">
    <canvas id="junction-detail" width="1400" height="900"></canvas>
  </div>
</div>

<div class="summary">
  <div class="summary-grid">
    <div class="summary-item"><div class="label">Pitch</div><div class="val" id="sum-pitch">20.0&deg;</div></div>
    <div class="summary-item"><div class="label">View Angle</div><div class="val" id="sum-angle">S (0&deg;)</div></div>
    <div class="summary-item"><div class="label">Connection Ht</div><div class="val" id="sum-conn-ht">--</div></div>
    <div class="summary-item"><div class="label">Horiz Span</div><div class="val" id="sum-span">--</div></div>
    <div class="summary-item"><div class="label">Rafter</div><div class="val" id="sum-rafter">--</div></div>
    <div class="summary-item"><div class="label">Junction Angle</div><div class="val" id="sum-junction">--</div></div>
  </div>
</div>

<script>
// ===================================================================
// Constants
// ===================================================================
const LEFT_WALL_H = 20.0;
const RIGHT_POST_H = 8.0;
const ROOF_DROP = LEFT_WALL_H - RIGHT_POST_H; // 12
const BACK_WALL_LEN = 30.0;
const DOME_R = 16.5;
const CONN_ANGLE_DEG = 20.0;
const WALL_ANGLE_DEG = -25.0;

const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// ===================================================================
// Geometry Engine
// ===================================================================
function computeGeometry(pitchDeg) {
  const rad = pitchDeg * DEG2RAD;
  const horizSpan = ROOF_DROP / Math.tan(rad);
  const wallX = (LEFT_WALL_H - 12.0) / Math.tan(rad);
  const rafterLen = ROOF_DROP / Math.sin(rad);
  const rightSection = horizSpan - wallX;
  return { pitchDeg, rad, horizSpan, wallX, rafterLen, rightSection };
}

// ===================================================================
// Drawing Utilities
// ===================================================================
function setupCanvas(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { ctx, w: rect.width, h: rect.height };
}

function makeTransform(w, h, xMin, xMax, yMin, yMax) {
  const padX = 0.08 * w, padY = 0.08 * h;
  const drawW = w - 2 * padX;
  const drawH = h - 2 * padY;
  const scaleX = drawW / (xMax - xMin);
  const scaleY = drawH / (yMax - yMin);
  const scale = Math.min(scaleX, scaleY);
  const offsetX = padX + (drawW - scale * (xMax - xMin)) / 2;
  const offsetY = padY + (drawH - scale * (yMax - yMin)) / 2;
  return {
    tx: (x) => offsetX + (x - xMin) * scale,
    ty: (y) => h - (offsetY + (y - yMin) * scale),
    scale,
  };
}

function drawLine(ctx, t, x1, y1, x2, y2, color, lw) {
  ctx.beginPath();
  ctx.moveTo(t.tx(x1), t.ty(y1));
  ctx.lineTo(t.tx(x2), t.ty(y2));
  ctx.strokeStyle = color || '#000';
  ctx.lineWidth = lw || 2;
  ctx.stroke();
}

function drawDot(ctx, t, x, y, r, color) {
  ctx.beginPath();
  ctx.arc(t.tx(x), t.ty(y), r || 4, 0, 2 * Math.PI);
  ctx.fillStyle = color || '#000';
  ctx.fill();
}

function drawText(ctx, t, x, y, text, opts) {
  opts = opts || {};
  ctx.save();
  ctx.font = (opts.weight || 'bold') + ' ' + (opts.size || 12) + 'px -apple-system, sans-serif';
  ctx.fillStyle = opts.color || '#333';
  ctx.textAlign = opts.align || 'center';
  ctx.textBaseline = opts.baseline || 'middle';
  var sx = t.tx(x), sy = t.ty(y);
  if (opts.rotation) {
    ctx.translate(sx, sy);
    ctx.rotate(-opts.rotation * DEG2RAD);
    ctx.fillText(text, 0, 0);
  } else {
    ctx.fillText(text, sx, sy);
  }
  ctx.restore();
}

function drawArc(ctx, t, cx, cy, r, startDeg, endDeg, color, lw) {
  var steps = 120;
  var s0 = startDeg * DEG2RAD;
  var s1 = endDeg * DEG2RAD;
  ctx.beginPath();
  for (var i = 0; i <= steps; i++) {
    var a = s0 + (s1 - s0) * i / steps;
    var px = cx + r * Math.cos(a);
    var py = cy + r * Math.sin(a);
    if (i === 0) ctx.moveTo(t.tx(px), t.ty(py));
    else ctx.lineTo(t.tx(px), t.ty(py));
  }
  ctx.strokeStyle = color || '#000';
  ctx.lineWidth = lw || 2;
  ctx.stroke();
}

function drawFilledArc(ctx, t, cx, cy, r, startDeg, endDeg, fillColor) {
  var steps = 60;
  var s0 = startDeg * DEG2RAD;
  var s1 = endDeg * DEG2RAD;
  ctx.beginPath();
  ctx.moveTo(t.tx(cx), t.ty(cy));
  for (var i = 0; i <= steps; i++) {
    var a = s0 + (s1 - s0) * i / steps;
    var px = cx + r * Math.cos(a);
    var py = cy + r * Math.sin(a);
    ctx.lineTo(t.tx(px), t.ty(py));
  }
  ctx.closePath();
  ctx.fillStyle = fillColor;
  ctx.fill();
}

function drawDimArrow(ctx, t, x1, y1, x2, y2, label, color, side) {
  // Dimension line with arrowheads and label
  var sx1 = t.tx(x1), sy1 = t.ty(y1);
  var sx2 = t.tx(x2), sy2 = t.ty(y2);
  var headLen = 6;
  var angle = Math.atan2(sy2 - sy1, sx2 - sx1);
  var c = color || '#555';

  ctx.beginPath();
  ctx.moveTo(sx1, sy1);
  ctx.lineTo(sx2, sy2);
  ctx.strokeStyle = c;
  ctx.lineWidth = 1;
  ctx.stroke();

  // Arrowheads
  for (var k = 0; k < 2; k++) {
    var sx = k === 0 ? sx1 : sx2;
    var sy = k === 0 ? sy1 : sy2;
    var dir = k === 0 ? 1 : -1;
    var a = angle + dir * Math.PI;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx + headLen * Math.cos(a - 0.4), sy + headLen * Math.sin(a - 0.4));
    ctx.lineTo(sx + headLen * Math.cos(a + 0.4), sy + headLen * Math.sin(a + 0.4));
    ctx.closePath();
    ctx.fillStyle = c;
    ctx.fill();
  }

  // Label
  var mx = (sx1 + sx2) / 2;
  var my = (sy1 + sy2) / 2;
  var offset = side === 'left' ? -14 : (side === 'right' ? 14 : -10);
  ctx.save();
  ctx.font = 'bold 11px -apple-system, sans-serif';
  ctx.fillStyle = c;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  // For vertical lines, offset horizontally; for horizontal, offset vertically
  var dx = Math.abs(sx2 - sx1);
  var dy = Math.abs(sy2 - sy1);
  if (dy > dx) {
    ctx.fillText(label, mx + offset, my);
  } else {
    ctx.fillText(label, mx, my + offset);
  }
  ctx.restore();
}

// ===================================================================
// Compass Label
// ===================================================================
function getCompassLabel(deg) {
  // 0°=S, 90°=E, 180°=N, 270°=W (clockwise compass)
  var dirs = ['S', 'SSE', 'SE', 'ESE', 'E', 'ENE', 'NE', 'NNE',
              'N', 'NNW', 'NW', 'WNW', 'W', 'WSW', 'SW', 'SSW'];
  var idx = Math.round(((deg % 360) + 360) % 360 / 22.5) % 16;
  return dirs[idx];
}

// ===================================================================
// 360° Elevation
// ===================================================================
function drawElevation(pitchDeg, viewAngleDeg, opaque) {
  var canvasId = opaque ? 'solid-elevation' : 'front-elevation';
  var canvas = document.getElementById(canvasId);
  var s = setupCanvas(canvas);
  var ctx = s.ctx, w = s.w, h = s.h;

  ctx.clearRect(0, 0, w, h);

  // Title with compass direction
  var compassDir = getCompassLabel(viewAngleDeg);
  var titlePrefix = opaque ? 'Solid Elevation' : 'Elevation';
  ctx.save();
  ctx.font = 'bold 14px -apple-system, sans-serif';
  ctx.fillStyle = '#2c3e50';
  ctx.textAlign = 'center';
  ctx.fillText(titlePrefix + ' \u2014 ' + compassDir + ' (' + viewAngleDeg + '\u00B0)', w / 2, 20);
  ctx.restore();

  var geo = computeGeometry(pitchDeg);

  // --- Projection setup ---
  // Convention: 0°=S, 90°=E, 180°=N, 270°=W
  // screen_x = wx*cos(α) + wy*sin(α)   (perpendicular to view)
  // depth    = -wx*sin(α) + wy*cos(α)   (positive = further from viewer)
  var alpha = viewAngleDeg * DEG2RAD;
  var cosA = Math.cos(alpha);
  var sinA = Math.sin(alpha);

  function projX(wx, wy) { return wx * cosA + wy * sinA; }
  function depthOf(wx, wy) { return -wx * sinA + wy * cosA; }

  // --- Constants ---
  var RISER_H = RIGHT_POST_H; // 8'
  var domeR = DOME_R;         // 16.5'
  var domePeak = RISER_H + domeR; // 24.5'

  // --- Wing geometry (plan view) ---
  var connAngle2d = CONN_ANGLE_DEG * DEG2RAD;
  var Px = domeR * Math.cos(connAngle2d);
  var Py = domeR * Math.sin(connAngle2d);
  var wallAngle = WALL_ANGLE_DEG * DEG2RAD;
  var Wx = Px + BACK_WALL_LEN * Math.cos(wallAngle);
  var Wy = Py + BACK_WALL_LEN * Math.sin(wallAngle);
  var w2Angle = wallAngle - Math.PI / 2;
  var w2DirX = Math.cos(w2Angle), w2DirY = Math.sin(w2Angle);
  var W2x = Wx + geo.wallX * w2DirX;
  var W2y = Wy + geo.wallX * w2DirY;
  var PostX = W2x + geo.rightSection * w2DirX;
  var PostY = W2y + geo.rightSection * w2DirY;

  // Dome connection at 20' height — on dome surface at plan angle 20°
  var domeConnR = Math.sqrt(domeR * domeR - (LEFT_WALL_H - RISER_H) * (LEFT_WALL_H - RISER_H));
  var connWx = domeConnR * Math.cos(connAngle2d);
  var connWy = domeConnR * Math.sin(connAngle2d);

  // Wing footprint: 3-corner L-shape (back wall + side wall, open porch front)
  // A = back wall at dome, B = back wall far end, C = post
  var ROOF_OVERHANG = 2;
  var rightWingPts = [
    { wx: Px, wy: Py, h: LEFT_WALL_H },
    { wx: Wx, wy: Wy, h: LEFT_WALL_H },
    { wx: PostX, wy: PostY, h: RIGHT_POST_H }
  ];
  // Roof overhang corners (extend past post + near-dome parallelogram corner)
  var rOH_C = { wx: PostX + ROOF_OVERHANG * w2DirX, wy: PostY + ROOF_OVERHANG * w2DirY };
  var rOH_D = { wx: Px + (PostX + ROOF_OVERHANG * w2DirX - Wx),
                wy: Py + (PostY + ROOF_OVERHANG * w2DirY - Wy) };
  var leftWingPts = rightWingPts.map(function(v) {
    return { wx: -v.wx, wy: v.wy, h: v.h };
  });
  var lOH_C = { wx: -rOH_C.wx, wy: rOH_C.wy };
  var lOH_D = { wx: -rOH_D.wx, wy: rOH_D.wy };

  // Entry box (plan-view footprint)
  var entryW = 8, entryH = 8, entryD = 5;
  var entryCorners = [
    { wx: -entryW / 2, wy: -(domeR + entryD) },
    { wx:  entryW / 2, wy: -(domeR + entryD) },
    { wx:  entryW / 2, wy: -domeR },
    { wx: -entryW / 2, wy: -domeR }
  ];
  var entryProjXs = entryCorners.map(function(c) { return projX(c.wx, c.wy); });
  var entryMinPX = Math.min.apply(null, entryProjXs);
  var entryMaxPX = Math.max.apply(null, entryProjXs);

  // Average depths for painter's algorithm
  var rightAvgD = rightWingPts.reduce(function(s, v) { return s + depthOf(v.wx, v.wy); }, 0) / 3;
  var leftAvgD  = leftWingPts.reduce(function(s, v) { return s + depthOf(v.wx, v.wy); }, 0) / 3;
  var entryAvgD = entryCorners.reduce(function(s, c) { return s + depthOf(c.wx, c.wy); }, 0) / entryCorners.length;

  // --- World bounds (stable across all rotation angles) ---
  var maxR = domeR;
  rightWingPts.concat([rOH_C, rOH_D]).forEach(function(v) {
    maxR = Math.max(maxR, Math.sqrt(v.wx * v.wx + v.wy * v.wy));
  });
  entryCorners.forEach(function(c) {
    maxR = Math.max(maxR, Math.sqrt(c.wx * c.wx + c.wy * c.wy));
  });
  var xMin = -maxR - 5;
  var xMax = maxR + 5;
  var yMin = -3;
  var yMax = domePeak + 3;

  var t = makeTransform(w, h, xMin, xMax, yMin, yMax);

  // --- Background ---
  if (opaque) {
    // Sky gradient
    var skyGrad = ctx.createLinearGradient(0, 0, 0, h);
    skyGrad.addColorStop(0, '#87CEEB');
    skyGrad.addColorStop(0.7, '#C8E6F0');
    skyGrad.addColorStop(1, '#E8F4E8');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, w, h);
    // Green ground
    ctx.fillStyle = '#7AB648';
    ctx.fillRect(t.tx(xMin), t.ty(0), t.tx(xMax) - t.tx(xMin), h - t.ty(0));
  }

  // --- Draw ground ---
  if (!opaque) {
    drawLine(ctx, t, xMin + 1, 0, xMax - 1, 0, '#8B7355', 2);
    ctx.save();
    ctx.fillStyle = '#f0ead6';
    ctx.fillRect(t.tx(xMin + 1), t.ty(0), t.tx(xMax - 1) - t.tx(xMin + 1), t.ty(-2) - t.ty(0));
    ctx.restore();
    drawText(ctx, t, 0, -1.5, 'GROUND', { size: 10, color: '#8B7355', weight: '600' });
  }

  // --- Drawing helpers ---

  function drawDomeShape() {
    if (opaque) {
      // Solid riser wall
      ctx.save();
      ctx.fillStyle = '#B8B0A0';
      ctx.fillRect(t.tx(-domeR), t.ty(RISER_H), t.tx(domeR) - t.tx(-domeR), t.ty(0) - t.ty(RISER_H));
      ctx.strokeStyle = '#8A8278';
      ctx.lineWidth = 1;
      ctx.strokeRect(t.tx(-domeR), t.ty(RISER_H), t.tx(domeR) - t.tx(-domeR), t.ty(0) - t.ty(RISER_H));
      ctx.restore();
      // Solid dome shell
      drawFilledArc(ctx, t, 0, RISER_H, domeR, 0, 180, '#D4E8EF');
      drawArc(ctx, t, 0, RISER_H, domeR, 0, 180, '#6A9BB5', 2);
    } else {
      // Riser wall
      ctx.save();
      ctx.fillStyle = 'rgba(180, 180, 170, 0.2)';
      ctx.fillRect(t.tx(-domeR), t.ty(RISER_H), t.tx(domeR) - t.tx(-domeR), t.ty(0) - t.ty(RISER_H));
      ctx.restore();
      drawLine(ctx, t, -domeR, 0, -domeR, RISER_H, '#666', 2);
      drawLine(ctx, t, domeR, 0, domeR, RISER_H, '#666', 2);
      drawLine(ctx, t, -domeR, RISER_H, domeR, RISER_H, '#666', 1.5);
      drawText(ctx, t, 0, RISER_H / 2, "RISER (8')", { size: 10, color: '#666', weight: '600' });
      // Dome shell
      drawFilledArc(ctx, t, 0, RISER_H, domeR, 0, 180, 'rgba(173, 216, 230, 0.15)');
      drawArc(ctx, t, 0, RISER_H, domeR, 0, 180, '#2c3e50', 2.5);
    }
  }

  // --- Wing drawing (shared geometry, both views) ---

  function drawWingShape(pts, color) {
    // 3-corner wing: A(back-dome), B(back-far), C(post)
    var pA = projX(pts[0].wx, pts[0].wy);
    var pB = projX(pts[1].wx, pts[1].wy);
    var pC = projX(pts[2].wx, pts[2].wy);
    var hA = pts[0].h, hB = pts[1].h, hC = pts[2].h;

    // Back wall face (A→B, both at 20')
    if (Math.abs(t.tx(pA) - t.tx(pB)) >= 3) {
      ctx.save();
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(t.tx(pA), t.ty(0));
      ctx.lineTo(t.tx(pB), t.ty(0));
      ctx.lineTo(t.tx(pB), t.ty(hB));
      ctx.lineTo(t.tx(pA), t.ty(hA));
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
      drawLine(ctx, t, pA, 0, pA, hA, color, 2);
      drawLine(ctx, t, pA, hA, pB, hB, color, 2.5);
    }

    // Side wall face (B→C, slopes 20'→8')
    if (Math.abs(t.tx(pB) - t.tx(pC)) >= 3) {
      ctx.save();
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(t.tx(pB), t.ty(0));
      ctx.lineTo(t.tx(pC), t.ty(0));
      ctx.lineTo(t.tx(pC), t.ty(hC));
      ctx.lineTo(t.tx(pB), t.ty(hB));
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
      drawLine(ctx, t, pC, 0, pC, hC, color, 2);
      drawLine(ctx, t, pB, hB, pC, hC, color, 2.5);
    }

    // Near side wall (C→A, slopes 8'→20') — porch-facing
    if (Math.abs(t.tx(pC) - t.tx(pA)) >= 3) {
      ctx.save();
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(t.tx(pC), t.ty(0));
      ctx.lineTo(t.tx(pA), t.ty(0));
      ctx.lineTo(t.tx(pA), t.ty(hA));
      ctx.lineTo(t.tx(pC), t.ty(hC));
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
      drawLine(ctx, t, pC, hC, pA, hA, color, 2.5);
    }

    // Corner at B + connection dot at A
    if (Math.abs(t.tx(pA) - t.tx(pB)) >= 3)
      drawLine(ctx, t, pB, 0, pB, hB, color, 1.5);
    drawDot(ctx, t, pA, hA, 5, color);
  }

  function drawEntryShape() {
    var projW = Math.abs(t.tx(entryMaxPX) - t.tx(entryMinPX));
    if (projW < 4) return;
    ctx.save();
    ctx.fillStyle = 'rgba(210, 180, 140, 0.3)';
    ctx.fillRect(t.tx(entryMinPX), t.ty(entryH),
      t.tx(entryMaxPX) - t.tx(entryMinPX), t.ty(0) - t.ty(entryH));
    ctx.restore();
    drawLine(ctx, t, entryMinPX, 0, entryMinPX, entryH, '#8B6914', 2);
    drawLine(ctx, t, entryMaxPX, 0, entryMaxPX, entryH, '#8B6914', 2);
    drawLine(ctx, t, entryMinPX, entryH, entryMaxPX, entryH, '#8B6914', 2);
    if (projW > 30)
      drawText(ctx, t, (entryMinPX + entryMaxPX) / 2, entryH / 2, 'ENTRY',
        { size: 11, color: '#8B6914', weight: '600' });
  }

  // --- Solid view: face-by-face 3D rendering ---

  function outwardNormal(P1, P2, cx, cy) {
    var dx = P2.wx - P1.wx, dy = P2.wy - P1.wy;
    var nx = -dy, ny = dx;
    var midx = (P1.wx + P2.wx) / 2 - cx;
    var midy = (P1.wy + P2.wy) / 2 - cy;
    if (nx * midx + ny * midy >= 0) return { x: nx, y: ny };
    return { x: dy, y: -dx };
  }

  function collectWingFaces(pts, ohC, ohD, faces) {
    // Same 3-corner geometry as transparent view
    var A = pts[0], B = pts[1], C = pts[2];
    var cx = (A.wx + B.wx + C.wx) / 3;
    var cy = (A.wy + B.wy + C.wy) / 3;
    var tvx = sinA, tvy = -cosA;

    // Back wall (A→B, 20'), far side (B→C, 20'→8'), near side (C→A, 8'→20')
    var wallDefs = [
      { p1: A, p2: B, h1: LEFT_WALL_H, h2: LEFT_WALL_H, color: '#B8A888' },
      { p1: B, p2: C, h1: LEFT_WALL_H, h2: RIGHT_POST_H, color: '#A89878' },
      { p1: C, p2: A, h1: RIGHT_POST_H, h2: LEFT_WALL_H, color: '#C8B898' }
    ];
    wallDefs.forEach(function(wd) {
      var n = outwardNormal(wd.p1, wd.p2, cx, cy);
      if (n.x * tvx + n.y * tvy <= 0) return;
      var p1x = projX(wd.p1.wx, wd.p1.wy);
      var p2x = projX(wd.p2.wx, wd.p2.wy);
      if (Math.abs(t.tx(p1x) - t.tx(p2x)) < 2) return;
      var d = (depthOf(wd.p1.wx, wd.p1.wy) + depthOf(wd.p2.wx, wd.p2.wy)) / 2;
      faces.push({
        depth: d,
        draw: function() {
          ctx.save();
          ctx.fillStyle = wd.color;
          ctx.beginPath();
          ctx.moveTo(t.tx(p1x), t.ty(0));
          ctx.lineTo(t.tx(p2x), t.ty(0));
          ctx.lineTo(t.tx(p2x), t.ty(wd.h2));
          ctx.lineTo(t.tx(p1x), t.ty(wd.h1));
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = '#6A5A3A';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
        }
      });
    });

    // Roof with overhang
    var pA = projX(A.wx, A.wy), pB = projX(B.wx, B.wy);
    var pCoh = projX(ohC.wx, ohC.wy), pDoh = projX(ohD.wx, ohD.wy);
    var roofD = (depthOf(A.wx, A.wy) + depthOf(B.wx, B.wy) +
                 depthOf(ohC.wx, ohC.wy) + depthOf(ohD.wx, ohD.wy)) / 4;
    faces.push({
      depth: roofD,
      draw: function() {
        ctx.save();
        ctx.fillStyle = '#8B7355';
        ctx.beginPath();
        ctx.moveTo(t.tx(pA), t.ty(LEFT_WALL_H));
        ctx.lineTo(t.tx(pB), t.ty(LEFT_WALL_H));
        ctx.lineTo(t.tx(pCoh), t.ty(RIGHT_POST_H));
        ctx.lineTo(t.tx(pDoh), t.ty(RIGHT_POST_H));
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#6A5A3A';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.restore();
      }
    });
  }

  function collectEntryFaces(faces) {
    var corners = entryCorners; // [far-left, far-right, near-right, near-left]
    var cx = 0, cy = -(domeR + entryD / 2);
    var tvx = sinA, tvy = -cosA;

    var wallPairs = [
      { p1: corners[0], p2: corners[1], color: '#C8B898' }, // front (far from dome)
      { p1: corners[1], p2: corners[2], color: '#A89878' }, // right side
      { p1: corners[2], p2: corners[3], color: '#C8B898' }, // back (near dome)
      { p1: corners[3], p2: corners[0], color: '#A89878' }  // left side
    ];

    wallPairs.forEach(function(wp) {
      var n = outwardNormal(wp.p1, wp.p2, cx, cy);
      if (n.x * tvx + n.y * tvy <= 0) return;
      var p1x = projX(wp.p1.wx, wp.p1.wy);
      var p2x = projX(wp.p2.wx, wp.p2.wy);
      if (Math.abs(t.tx(p1x) - t.tx(p2x)) < 2) return;
      var d = (depthOf(wp.p1.wx, wp.p1.wy) + depthOf(wp.p2.wx, wp.p2.wy)) / 2;
      faces.push({
        depth: d,
        draw: function() {
          ctx.save();
          ctx.fillStyle = wp.color;
          ctx.beginPath();
          ctx.moveTo(t.tx(p1x), t.ty(0));
          ctx.lineTo(t.tx(p2x), t.ty(0));
          ctx.lineTo(t.tx(p2x), t.ty(entryH));
          ctx.lineTo(t.tx(p1x), t.ty(entryH));
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = '#6A5A3A';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
        }
      });
    });

    // Entry roof (flat at entryH)
    var pts = corners.map(function(c) { return projX(c.wx, c.wy); });
    var roofD = corners.reduce(function(s, c) { return s + depthOf(c.wx, c.wy); }, 0) / 4;
    faces.push({
      depth: roofD,
      draw: function() {
        ctx.save();
        ctx.fillStyle = '#8B7355';
        ctx.beginPath();
        for (var i = 0; i < pts.length; i++) {
          if (i === 0) ctx.moveTo(t.tx(pts[i]), t.ty(entryH));
          else ctx.lineTo(t.tx(pts[i]), t.ty(entryH));
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#6A5A3A';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }
    });
  }

  // --- Depth-sorted drawing ---
  if (opaque) {
    // Face-by-face rendering for proper occlusion
    var allFaces = [];
    // Dome shell (semicircle) at center depth — sits above riser, no vertical overlap with wings
    allFaces.push({ depth: 0, draw: function() {
      drawFilledArc(ctx, t, 0, RISER_H, domeR, 0, 180, '#D4E8EF');
      drawArc(ctx, t, 0, RISER_H, domeR, 0, 180, '#6A9BB5', 2);
    } });
    // Riser wall at front of dome cylinder — depth = -domeR so it draws in front of wing roofs
    allFaces.push({ depth: -domeR, draw: function() {
      ctx.save();
      ctx.fillStyle = '#B8B0A0';
      ctx.fillRect(t.tx(-domeR), t.ty(RISER_H), t.tx(domeR) - t.tx(-domeR), t.ty(0) - t.ty(RISER_H));
      ctx.strokeStyle = '#8A8278';
      ctx.lineWidth = 1;
      ctx.strokeRect(t.tx(-domeR), t.ty(RISER_H), t.tx(domeR) - t.tx(-domeR), t.ty(0) - t.ty(RISER_H));
      ctx.restore();
    } });
    collectWingFaces(rightWingPts, rOH_C, rOH_D, allFaces);
    collectWingFaces(leftWingPts, lOH_C, lOH_D, allFaces);
    collectEntryFaces(allFaces);
    allFaces.sort(function(a, b) { return b.depth - a.depth; });
    allFaces.forEach(function(f) { f.draw(); });
  } else {
    // Element-level sorting for transparent view
    var elements = [
      { type: 'dome',  avgDepth: 0 },
      { type: 'right', avgDepth: rightAvgD },
      { type: 'left',  avgDepth: leftAvgD },
      { type: 'entry', avgDepth: entryAvgD }
    ];
    elements.sort(function(a, b) { return b.avgDepth - a.avgDepth; });
    elements.forEach(function(el) {
      switch (el.type) {
        case 'dome':  drawDomeShape(); break;
        case 'right': drawWingShape(rightWingPts, '#c0392b'); break;
        case 'left':  drawWingShape(leftWingPts, '#c0392b'); break;
        case 'entry': drawEntryShape(); break;
      }
    });

    // Dimension lines
    var dimX = xMax - 3;
    drawDimArrow(ctx, t, dimX, 0, dimX, domePeak, domePeak.toFixed(1) + "'", '#2c3e50', 'right');
    drawText(ctx, t, dimX + 2.5, domePeak - 2, 'PEAK', { size: 9, color: '#2c3e50', weight: '600', align: 'left' });
    var dimXR = -domeR - 2;
    drawDimArrow(ctx, t, dimXR, 0, dimXR, RISER_H, RISER_H.toFixed(0) + "'", '#666', 'left');
    drawDimArrow(ctx, t, -domeR, -1.8, domeR, -1.8, (domeR * 2).toFixed(0) + "' dia", '#2c3e50');
    // Wing heights: [0]=back wall at dome, [2]=post
    var nearWing = (rightAvgD < leftAvgD) ? rightWingPts : leftWingPts;
    var nearConnPX = projX(nearWing[0].wx, nearWing[0].wy);
    var nearPostPX = projX(nearWing[2].wx, nearWing[2].wy);
    drawDimArrow(ctx, t, nearConnPX + 2, 0, nearConnPX + 2, LEFT_WALL_H,
      LEFT_WALL_H.toFixed(0) + "'", '#c0392b', 'right');
    drawDimArrow(ctx, t, nearPostPX + 2, 0, nearPostPX + 2, RIGHT_POST_H,
      RIGHT_POST_H.toFixed(0) + "'", '#c0392b', 'right');
  }
}

// ===================================================================
// Junction Detail
// ===================================================================
function drawJunctionDetail(pitchDeg) {
  var canvas = document.getElementById('junction-detail');
  var s = setupCanvas(canvas);
  var ctx = s.ctx, w = s.w, h = s.h;

  ctx.clearRect(0, 0, w, h);

  // Title
  ctx.save();
  ctx.font = 'bold 14px -apple-system, sans-serif';
  ctx.fillStyle = '#2c3e50';
  ctx.textAlign = 'center';
  ctx.fillText('Junction Detail \u2014 Wing Roof Meets Dome', w / 2, 20);
  ctx.restore();

  var geo = computeGeometry(pitchDeg);

  // Dome geometry — dome sits on 8' riser
  var RISER_H = RIGHT_POST_H; // 8'
  var domeCX = 0;
  var domeCY = RISER_H; // dome center at top of riser
  var domeR = DOME_R;

  // Connection point at LEFT_WALL_H (20') above ground
  var connHeight = LEFT_WALL_H;
  var connSinA = (connHeight - RISER_H) / domeR;
  connSinA = Math.min(1, Math.max(-1, connSinA));
  var connAngle = Math.asin(connSinA);
  var connAngleDeg = connAngle * RAD2DEG;
  var connX = domeR * Math.cos(connAngle);
  var connY = connHeight; // 20' above ground

  // Zoomed view: center on connection point, show about 10' around it
  var viewR = 8;
  var xMin = connX - viewR;
  var xMax = connX + viewR;
  var yMin = connY - viewR;
  var yMax = connY + viewR;

  var t = makeTransform(w, h, xMin, xMax, yMin, yMax);

  // Background grid (subtle)
  ctx.save();
  ctx.strokeStyle = 'rgba(0,0,0,0.04)';
  ctx.lineWidth = 0.5;
  for (var gx = Math.floor(xMin); gx <= Math.ceil(xMax); gx++) {
    ctx.beginPath();
    ctx.moveTo(t.tx(gx), t.ty(yMin));
    ctx.lineTo(t.tx(gx), t.ty(yMax));
    ctx.stroke();
  }
  for (var gy = Math.floor(yMin); gy <= Math.ceil(yMax); gy++) {
    ctx.beginPath();
    ctx.moveTo(t.tx(xMin), t.ty(gy));
    ctx.lineTo(t.tx(xMax), t.ty(gy));
    ctx.stroke();
  }
  ctx.restore();

  // Dome arc (section from -10 to +50 around connection point)
  var arcStart = connAngleDeg - 25;
  var arcEnd = connAngleDeg + 35;
  // Dome shell fill (section)
  drawFilledArc(ctx, t, domeCX, domeCY, domeR, arcStart, arcEnd, 'rgba(173, 216, 230, 0.12)');
  // Inner side of dome (slightly smaller radius to show shell thickness)
  var shellThick = 0.3;
  drawArc(ctx, t, domeCX, domeCY, domeR, arcStart, arcEnd, '#2c3e50', 3);
  drawArc(ctx, t, domeCX, domeCY, domeR - shellThick, arcStart, arcEnd, '#2c3e50', 1);

  // Radius line from dome center toward connection point (dashed)
  // Only draw the visible portion
  var radEndX = connX;
  var radEndY = connY;
  var radStartX = domeCX + (domeR - viewR * 1.2) * Math.cos(connAngle);
  var radStartY = domeCY + (domeR - viewR * 1.2) * Math.sin(connAngle);
  // Clamp to view
  if (radStartX < xMin) {
    var frac = (xMin - domeCX) / (connX - domeCX);
    radStartX = xMin;
    radStartY = domeCY + frac * (connY - domeCY);
  }

  ctx.save();
  ctx.setLineDash([4, 4]);
  drawLine(ctx, t, radStartX, radStartY, radEndX, radEndY, '#999', 1.5);
  ctx.setLineDash([]);
  ctx.restore();

  // Connection point (big dot)
  drawDot(ctx, t, connX, connY, 7, '#c0392b');

  // --- Dome tangent at connection point ---
  // Tangent is perpendicular to the radius. Radius direction is (cos(connAngle), sin(connAngle))
  // Tangent direction is (-sin(connAngle), cos(connAngle))
  var tangDx = -Math.sin(connAngle);
  var tangDy = Math.cos(connAngle);
  var tangLen = 6; // feet to draw in each direction

  // Draw tangent line (both directions from connection point)
  var tang1X = connX - tangLen * tangDx;
  var tang1Y = connY - tangLen * tangDy;
  var tang2X = connX + tangLen * tangDx;
  var tang2Y = connY + tangLen * tangDy;

  ctx.save();
  ctx.setLineDash([6, 3]);
  drawLine(ctx, t, tang1X, tang1Y, tang2X, tang2Y, '#27ae60', 2);
  ctx.setLineDash([]);
  ctx.restore();

  // Label tangent
  drawText(ctx, t, tang2X + 0.3, tang2Y + 0.8, 'DOME TANGENT', {
    size: 10, color: '#27ae60', weight: '600', align: 'left'
  });

  // --- Wing roof line ---
  // The wing roof departs from the connection point going right and downward
  // at the pitch angle below horizontal
  var pitchRad = pitchDeg * DEG2RAD;
  // Wing goes outward (to the right) and downward. Direction: (cos(-pitch), sin(-pitch))
  var wingDx = Math.cos(-pitchRad);
  var wingDy = Math.sin(-pitchRad);
  var wingLen = 7; // feet to draw

  var wingEndX = connX + wingLen * wingDx;
  var wingEndY = connY + wingLen * wingDy;

  drawLine(ctx, t, connX, connY, wingEndX, wingEndY, '#c0392b', 2.5);

  // Wing direction arrow
  var arrowX = connX + (wingLen - 1) * wingDx;
  var arrowY = connY + (wingLen - 1) * wingDy;
  drawDot(ctx, t, wingEndX, wingEndY, 4, '#c0392b');

  // Label wing roof
  var wingMidX = connX + wingLen * 0.5 * wingDx;
  var wingMidY = connY + wingLen * 0.5 * wingDy;
  drawText(ctx, t, wingMidX - 0.5, wingMidY - 1, 'WING ROOF', {
    size: 10, color: '#c0392b', weight: '600'
  });

  // --- Angles ---
  // 1. Dome tangent angle from horizontal: tangent direction is (-sin(conn), cos(conn))
  //    The tangent going upward-left makes angle = (90 + connAngleDeg) from positive x-axis
  //    The tangent going downward-right makes angle = -(90 - connAngleDeg) from positive x-axis
  //    Tangent going up to the right (from connection): angle = 90 + connAngleDeg measured from +x
  //    Actually: tangent direction (tangDx, tangDy) = (-sin(20), cos(20))
  //    Angle of this from +x axis = atan2(cos(20), -sin(20)) = 90+20 = 110 degrees

  // The downward tangent direction (toward lower dome surface):
  var tangDownAngle = (90 + connAngleDeg + 180); // degrees from +x axis (going down-right on dome)
  // Simplify: tangent going down-right = (sin(connAngle), -cos(connAngle))
  var tangDownDx = Math.sin(connAngle);
  var tangDownDy = -Math.cos(connAngle);
  var tangDownAngleDeg = Math.atan2(tangDownDy, tangDownDx) * RAD2DEG; // negative angle

  // Wing roof angle from +x axis
  var wingAngleDeg = Math.atan2(wingDy, wingDx) * RAD2DEG; // negative

  // Junction angle = angle between dome tangent (going down-right) and wing roof line
  // Both go "away" from connection point; the angle between them is what the builder cares about
  var junctionAngle = Math.abs(wingAngleDeg - tangDownAngleDeg);
  if (junctionAngle > 180) junctionAngle = 360 - junctionAngle;

  // Draw angle arc: between the tangent (going down) and the wing roof line
  // Arc centered at connection point
  var arcR = 3; // feet
  var arcAngle1 = tangDownAngleDeg;
  var arcAngle2 = wingAngleDeg;
  // Ensure we go the short way
  if (arcAngle1 > arcAngle2) {
    var tmp = arcAngle1;
    arcAngle1 = arcAngle2;
    arcAngle2 = tmp;
  }
  if (arcAngle2 - arcAngle1 > 180) {
    arcAngle1 += 360;
    var tmp2 = arcAngle1;
    arcAngle1 = arcAngle2;
    arcAngle2 = tmp2;
  }

  // Draw filled angle wedge
  drawFilledArc(ctx, t, connX, connY, arcR, arcAngle1, arcAngle2, 'rgba(231, 76, 60, 0.15)');
  drawArc(ctx, t, connX, connY, arcR, arcAngle1, arcAngle2, '#e74c3c', 2);

  // Junction angle label
  var midArcAngle = (arcAngle1 + arcAngle2) / 2 * DEG2RAD;
  var labelR = arcR + 1.2;
  var labelX = connX + labelR * Math.cos(midArcAngle);
  var labelY = connY + labelR * Math.sin(midArcAngle);
  drawText(ctx, t, labelX, labelY, junctionAngle.toFixed(1) + '\u00B0', {
    size: 13, color: '#e74c3c', weight: '700'
  });
  drawText(ctx, t, labelX, labelY - 1, 'JUNCTION', {
    size: 9, color: '#e74c3c', weight: '600'
  });

  // --- Pitch angle arc (from horizontal to wing roof) ---
  var pitchArcR = 4.5;
  var pitchArc1 = Math.min(0, wingAngleDeg);
  var pitchArc2 = Math.max(0, wingAngleDeg);
  if (wingAngleDeg < 0) {
    pitchArc1 = wingAngleDeg;
    pitchArc2 = 0;
  }
  drawArc(ctx, t, connX, connY, pitchArcR, pitchArc1, pitchArc2, '#2980b9', 1.5);

  // Pitch label
  var pitchMidAngle = (pitchArc1 + pitchArc2) / 2 * DEG2RAD;
  var pitchLabelR = pitchArcR + 1;
  var pitchLabelX = connX + pitchLabelR * Math.cos(pitchMidAngle);
  var pitchLabelY = connY + pitchLabelR * Math.sin(pitchMidAngle);
  drawText(ctx, t, pitchLabelX, pitchLabelY, pitchDeg.toFixed(1) + '\u00B0 pitch', {
    size: 11, color: '#2980b9', weight: '700'
  });

  // Horizontal reference line
  ctx.save();
  ctx.setLineDash([3, 3]);
  drawLine(ctx, t, connX, connY, connX + 6, connY, '#2980b9', 1);
  ctx.setLineDash([]);
  ctx.restore();
  drawText(ctx, t, connX + 6.3, connY + 0.4, 'HORIZ', {
    size: 9, color: '#2980b9', weight: '600', align: 'left'
  });

  // --- Dome tangent angle from horizontal ---
  // The tangent going up-left from connection: angle = 90 + connAngleDeg from +x
  // The dome tangent at this point makes angle (90 - connAngleDeg) with horizontal
  // Actually at connAngle=20 above horizontal, the tangent to the circle is perpendicular to radius
  // Radius at 20 deg is at angle 20 from horizontal, so tangent is at 20+90=110 from +x axis
  // Tangent angle from horizontal = 90 - connAngleDeg... no.
  // Let's think: tangent direction going upward = (-sin(20), cos(20)) = angle 110 from +x
  // So from horizontal it's 110 degrees. The angle between horizontal and tangent = 110 - 180 = ...
  // Going the other way: tangent going down-right = (sin(20), -cos(20))
  // angle from +x = atan2(-cos(20), sin(20)) = about -70 degrees
  // So dome tangent going down makes 70 degrees below horizontal
  var tangFromHoriz = 90 - connAngleDeg; // degrees below horizontal for down-going tangent

  // Draw small dome tangent angle arc
  var dtArcR = 2;
  // Arc from tangent-down angle to horizontal (0)
  var dtArc1 = tangDownAngleDeg; // negative
  var dtArc2 = 0;
  if (dtArc1 > dtArc2) { var tt = dtArc1; dtArc1 = dtArc2; dtArc2 = tt; }

  ctx.save();
  ctx.setLineDash([2, 2]);
  drawArc(ctx, t, connX, connY, dtArcR, dtArc1, dtArc2, '#27ae60', 1.5);
  ctx.setLineDash([]);
  ctx.restore();

  var dtMidAngle = (dtArc1 + dtArc2) / 2 * DEG2RAD;
  var dtLabelR = dtArcR + 0.8;
  var dtLabelX = connX + dtLabelR * Math.cos(dtMidAngle);
  var dtLabelY = connY + dtLabelR * Math.sin(dtMidAngle);
  drawText(ctx, t, dtLabelX - 0.2, dtLabelY, tangFromHoriz.toFixed(0) + '\u00B0', {
    size: 9, color: '#27ae60', weight: '600'
  });

  // Connection point label
  drawText(ctx, t, connX - 1.5, connY + 1, 'CONNECTION', {
    size: 10, color: '#c0392b', weight: '700'
  });
  drawText(ctx, t, connX - 1.5, connY + 0.2, '(' + connX.toFixed(1) + "', " + connY.toFixed(1) + "')", {
    size: 9, color: '#666', weight: '600'
  });

  // Legend box in bottom-left
  ctx.save();
  var lx = 12, ly = h - 70;
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  ctx.fillRect(lx, ly, 200, 60);
  ctx.strokeRect(lx, ly, 200, 60);
  ctx.font = 'bold 10px -apple-system, sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';

  // Legend items
  var items = [
    ['#2c3e50', 'Dome shell'],
    ['#27ae60', 'Dome tangent (' + tangFromHoriz.toFixed(0) + '\u00B0 from horiz)'],
    ['#c0392b', 'Wing roof (' + pitchDeg.toFixed(1) + '\u00B0 pitch)'],
    ['#e74c3c', 'Junction angle: ' + junctionAngle.toFixed(1) + '\u00B0'],
  ];
  for (var i = 0; i < items.length; i++) {
    ctx.fillStyle = items[i][0];
    ctx.fillRect(lx + 8, ly + 10 + i * 13, 10, 3);
    ctx.fillText(items[i][1], lx + 24, ly + 11 + i * 13);
  }
  ctx.restore();

  return { connHeight: connY, junctionAngle: junctionAngle };
}

// ===================================================================
// Update loop
// ===================================================================
function update() {
  var pitchSlider = document.getElementById('pitch-slider');
  var angleSlider = document.getElementById('angle-slider');
  var pitchDeg = parseFloat(pitchSlider.value);
  var viewAngleDeg = parseFloat(angleSlider.value);
  var geo = computeGeometry(pitchDeg);
  var compassDir = getCompassLabel(viewAngleDeg);

  document.getElementById('pitch-value').innerHTML = pitchDeg.toFixed(1) + '&deg;';
  document.getElementById('sum-pitch').innerHTML = pitchDeg.toFixed(1) + '&deg;';
  document.getElementById('angle-value').innerHTML = compassDir + ' ' + viewAngleDeg + '&deg;';
  document.getElementById('sum-angle').innerHTML = compassDir + ' (' + viewAngleDeg + '&deg;)';

  drawElevation(pitchDeg, viewAngleDeg, false);
  drawElevation(pitchDeg, viewAngleDeg, true);
  var jd = drawJunctionDetail(pitchDeg);

  document.getElementById('sum-conn-ht').textContent = jd.connHeight.toFixed(1) + "'";
  document.getElementById('sum-span').textContent = geo.horizSpan.toFixed(1) + "'";
  document.getElementById('sum-rafter').textContent = geo.rafterLen.toFixed(1) + "'";
  document.getElementById('sum-junction').textContent = jd.junctionAngle.toFixed(1) + '\u00B0';
}

// ===================================================================
// Init
// ===================================================================
var pitchSlider = document.getElementById('pitch-slider');
var angleSlider = document.getElementById('angle-slider');

// Load from URL hash
var hash = window.location.hash.slice(1);
if (hash) {
  var params = new URLSearchParams(hash);
  var p = parseFloat(params.get('pitch'));
  if (p >= 20 && p <= 35) pitchSlider.value = p;
  var a = parseFloat(params.get('angle'));
  if (a >= 0 && a <= 360) angleSlider.value = a;
}

function updateHash() {
  var hash = '#pitch=' + parseFloat(pitchSlider.value).toFixed(1) +
    '&angle=' + parseFloat(angleSlider.value);
  history.replaceState(null, '', hash);
}

pitchSlider.addEventListener('input', function() { update(); updateHash(); });
angleSlider.addEventListener('input', function() { update(); updateHash(); });

// Responsive resize
window.addEventListener('resize', update);

// Listen for changes from parent (iframe sync)
window.addEventListener('message', function(e) {
  if (e.data && e.data.type === 'setPitch') {
    var v = parseFloat(e.data.value);
    if (v >= 20 && v <= 35) { pitchSlider.value = v; update(); }
  }
  if (e.data && e.data.type === 'setViewAngle') {
    var v = parseFloat(e.data.value);
    if (v >= 0 && v <= 360) { angleSlider.value = v; update(); }
  }
});

update();
</script>
</body>
</html>
