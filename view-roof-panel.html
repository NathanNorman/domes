<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hippie Hideout — Wing Roof Panel</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #f5f5f0;
    color: #333;
    min-height: 100vh;
  }
  header {
    background: #2c3e50;
    color: white;
    padding: 16px 24px;
    text-align: center;
  }
  header h1 { font-size: 1.4em; font-weight: 600; letter-spacing: 0.02em; }
  header p { font-size: 0.85em; opacity: 0.7; margin-top: 4px; }

  .canvas-row {
    display: flex;
    gap: 12px;
    padding: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }
  .canvas-wrap {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    padding: 8px;
    flex: 1 1 600px;
    max-width: 900px;
    min-width: 320px;
  }
  canvas {
    width: 100%;
    height: auto;
    display: block;
    cursor: crosshair;
  }

  .controls {
    max-width: 700px;
    margin: 0 auto;
    padding: 0 16px 8px;
  }
  .slider-row {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
  }
  .slider-row label {
    font-weight: 600;
    font-size: 0.95em;
    white-space: nowrap;
  }
  .slider-row input[type=range] {
    flex: 1;
    accent-color: #2c3e50;
    height: 6px;
  }
  .slider-row .value {
    font-weight: 700;
    font-size: 1.1em;
    min-width: 42px;
    text-align: right;
    color: #c0392b;
  }

  .summary {
    max-width: 900px;
    margin: 8px auto;
    padding: 0 16px;
  }
  .summary-grid {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    padding: 12px 20px;
    justify-content: center;
  }
  .summary-item {
    text-align: center;
    min-width: 100px;
  }
  .summary-item .label { font-size: 0.75em; color: #888; text-transform: uppercase; letter-spacing: 0.05em; }
  .summary-item .val { font-size: 1.3em; font-weight: 700; color: #2c3e50; }

  .material-box {
    max-width: 900px;
    margin: 8px auto;
    padding: 0 16px 16px;
  }
  .material-card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    padding: 16px 20px;
    display: flex;
    gap: 24px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .material-card .mat-item {
    text-align: center;
  }
  .material-card .mat-label { font-size: 0.75em; color: #888; text-transform: uppercase; letter-spacing: 0.05em; }
  .material-card .mat-val { font-size: 1.5em; font-weight: 700; color: #c0392b; }
  .material-card .mat-note { font-size: 0.8em; color: #999; margin-top: 2px; }

  .actions {
    text-align: center;
    padding: 12px;
  }
  .actions button {
    background: #2c3e50;
    color: white;
    border: none;
    padding: 8px 18px;
    border-radius: 5px;
    font-size: 0.85em;
    cursor: pointer;
    margin: 0 4px;
    transition: background 0.2s;
  }
  .actions button:hover { background: #34495e; }

  @media (max-width: 768px) {
    .canvas-row { flex-direction: column; align-items: center; padding: 8px; gap: 8px; }
    .canvas-wrap { max-width: 100%; flex: 0 0 auto; }
    header h1 { font-size: 1.1em; }
    header { padding: 10px 16px; }
    .controls { padding: 0 8px 4px; }
    .summary { padding: 0 8px; }
    .summary-grid { padding: 8px 12px; gap: 8px; }
    .summary-item .val { font-size: 1.1em; }
    .material-box { padding: 0 8px 8px; }
    .material-card { padding: 12px; gap: 16px; }
    .actions { padding: 8px; }
    .actions button { padding: 6px 12px; font-size: 0.8em; }
  }
  @media print {
    header { background: white; color: black; }
    .controls, .actions { display: none; }
    .canvas-wrap { box-shadow: none; border: 1px solid #ccc; }
    body { background: white; }
  }
</style>
</head>
<body>

<header>
  <h1>Hippie Hideout — Wing Roof Panel</h1>
  <p>Plan-view wing shape stretched for true surface dimensions</p>
</header>

<div class="canvas-row">
  <div class="canvas-wrap">
    <canvas id="panel" width="1400" height="1000"></canvas>
  </div>
</div>

<div class="controls">
  <div class="slider-row">
    <label for="pitch-slider">Roof Pitch:</label>
    <input type="range" id="pitch-slider" min="20" max="35" step="0.5" value="20">
    <span class="value" id="pitch-value">20.0&deg;</span>
  </div>
</div>

<div class="summary">
  <div class="summary-grid">
    <div class="summary-item"><div class="label">Back Wall (ridge)</div><div class="val" id="sum-back">30.0'</div></div>
    <div class="summary-item"><div class="label">Wing Wall</div><div class="val" id="sum-wing">--</div></div>
    <div class="summary-item"><div class="label">Extension</div><div class="val" id="sum-ext">--</div></div>
    <div class="summary-item"><div class="label">Bottom Wall</div><div class="val" id="sum-bottom">--</div></div>
    <div class="summary-item"><div class="label">Dome Edge</div><div class="val" id="sum-dome">--</div></div>
    <div class="summary-item"><div class="label">Panel Area</div><div class="val" id="sum-area">--</div></div>
  </div>
</div>

<div class="material-box">
  <div class="material-card">
    <div class="mat-item">
      <div class="mat-label">Panel Area</div>
      <div class="mat-val" id="mat-area">--</div>
      <div class="mat-note">sq ft</div>
    </div>
    <div class="mat-item">
      <div class="mat-label">+ 10% Waste</div>
      <div class="mat-val" id="mat-waste">--</div>
      <div class="mat-note">sq ft</div>
    </div>
    <div class="mat-item">
      <div class="mat-label">Material Needed</div>
      <div class="mat-val" id="mat-total">--</div>
      <div class="mat-note">sq ft (total)</div>
    </div>
    <div class="mat-item">
      <div class="mat-label">Roofing Squares</div>
      <div class="mat-val" id="mat-squares">--</div>
      <div class="mat-note">1 square = 100 sq ft</div>
    </div>
  </div>
</div>

<div class="actions">
  <button onclick="exportPNG()">Export PNG</button>
  <button onclick="shareLink()">Copy Share Link</button>
</div>

<script>
// ===================================================================
// Constants
// ===================================================================
var LEFT_WALL_H = 20.0;
var RIGHT_POST_H = 8.0;
var ROOF_DROP = LEFT_WALL_H - RIGHT_POST_H; // 12
var INTERIOR_WALL_H = 12.0;
var BACK_WALL_LEN = 30.0;
var DOME_R = 16.5;
var CONN_ANGLE_DEG = 20.0;
var WALL_ANGLE_DEG = -25.0;
var DEG2RAD = Math.PI / 180;

// ===================================================================
// Geometry Engine
// ===================================================================
function computeGeometry(pitchDeg) {
  var rad = pitchDeg * DEG2RAD;
  var horizSpan = ROOF_DROP / Math.tan(rad);
  var wallX = (LEFT_WALL_H - INTERIOR_WALL_H) / Math.tan(rad);
  var rafterLen = ROOF_DROP / Math.sin(rad);
  var rightSection = horizSpan - wallX;
  return { pitchDeg: pitchDeg, rad: rad, horizSpan: horizSpan, wallX: wallX, rafterLen: rafterLen, rightSection: rightSection };
}

// ===================================================================
// Unfolded Panel via Plan-View Shape + Slope Stretch
//
// Instead of complex 3D unfolding, take the actual wing polygon from
// the floor plan (5 vertices: P, W, W2, Post, W3) and stretch it
// perpendicular to the back wall by 1/cos(pitch). This accounts for
// the roof slope and produces a shape the user recognizes as the wing.
//
// Vertices (plan view):
//   P    = dome connection point at (R*cos(20°), R*sin(20°))
//   W    = back wall end, 30' from P at -25°
//   W2   = wing wall corner, wallX perpendicular from W
//   Post = outer post, rightSection further in same direction
//   W3   = bottom wall dome intersection (quadratic from W2)
//
// The roof is a single plane sloping from the back wall (ridge at 20')
// down to the posts. All heights verify:
//   P=20', W=20', W2=12', Post=8', W3=12'
// ===================================================================

function computeUnfoldedPanel(g) {
  var connRad = CONN_ANGLE_DEG * DEG2RAD;
  var wallAngle = WALL_ANGLE_DEG * DEG2RAD;
  var r = DOME_R;

  // --- Plan-view coordinates of the 5 vertices ---
  var Px = r * Math.cos(connRad);
  var Py = r * Math.sin(connRad);

  var Wx = Px + BACK_WALL_LEN * Math.cos(wallAngle);
  var Wy = Py + BACK_WALL_LEN * Math.sin(wallAngle);

  var w2Angle = wallAngle - Math.PI / 2;
  var w2DirX = Math.cos(w2Angle), w2DirY = Math.sin(w2Angle);

  var W2x = Wx + g.wallX * w2DirX;
  var W2y = Wy + g.wallX * w2DirY;

  var PostX = W2x + g.rightSection * w2DirX;
  var PostY = W2y + g.rightSection * w2DirY;

  // W3: bottom wall from W2 toward dome (parallel to back wall, same as geometry-explorer)
  var w3Angle = w2Angle - Math.PI / 2;
  var w3DirX = Math.cos(w3Angle), w3DirY = Math.sin(w3Angle);
  var aCoef = 1.0;
  var bCoef = 2 * (W2x * w3DirX + W2y * w3DirY);
  var cCoef = W2x * W2x + W2y * W2y - r * r;
  var disc = bCoef * bCoef - 4 * aCoef * cCoef;
  var W3x, W3y;
  if (disc >= 0) {
    var tHit = (-bCoef - Math.sqrt(disc)) / (2 * aCoef);
    W3x = W2x + tHit * w3DirX;
    W3y = W2y + tHit * w3DirY;
  } else {
    W3x = Px; W3y = Py;
  }

  // --- Stretch in world space perpendicular to back wall ---
  // This keeps the same orientation as the floor plan so the shape
  // is immediately recognizable.
  var uParaX = Math.cos(wallAngle), uParaY = Math.sin(wallAngle);
  var uPerpX = Math.sin(wallAngle), uPerpY = -Math.cos(wallAngle);
  var stretchFactor = 1 / Math.cos(g.rad);

  function stretchWorld(vx, vy) {
    var dx = vx - Px, dy = vy - Py;
    var para = dx * uParaX + dy * uParaY;
    var perp = dx * uPerpX + dy * uPerpY;
    perp *= stretchFactor;
    return [Px + para * uParaX + perp * uPerpX,
            Py + para * uParaY + perp * uPerpY];
  }

  var sP = stretchWorld(Px, Py);
  var sW = stretchWorld(Wx, Wy);
  var sW2 = stretchWorld(W2x, W2y);
  var sPost = stretchWorld(PostX, PostY);
  var sW3 = stretchWorld(W3x, W3y);

  // --- Edge length helper ---
  function dist(a, b) {
    var dx = b[0] - a[0], dy = b[1] - a[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  // --- Sample dome arc from W3 to P (curved dome edge) ---
  var ARC_N = 40;
  var arcAngleW3 = Math.atan2(W3y, W3x);
  var arcAngleP = Math.atan2(Py, Px);
  var arcSpan = arcAngleP - arcAngleW3;
  while (arcSpan > Math.PI) arcSpan -= 2 * Math.PI;
  while (arcSpan < -Math.PI) arcSpan += 2 * Math.PI;

  var arcPtsStretched = [];
  for (var ai = 1; ai < ARC_N; ai++) {
    var theta = arcAngleW3 + ai * arcSpan / ARC_N;
    var ax = r * Math.cos(theta), ay = r * Math.sin(theta);
    arcPtsStretched.push(stretchWorld(ax, ay));
  }

  // Full polygon: 5 main vertices + arc samples (W3 → arc → P)
  var pts = [sP, sW, sW2, sPost, sW3].concat(arcPtsStretched);
  var mainVerts = [sP, sW, sW2, sPost, sW3];

  // --- Straight edge lengths ---
  var edgePW = dist(sP, sW);
  var edgeWW2 = dist(sW, sW2);
  var edgeW2Post = dist(sW2, sPost);
  var edgePostW3 = dist(sPost, sW3);

  // --- Dome arc length (sum of segments in stretched space) ---
  var domeArcLen = 0;
  var arcPrev = sW3;
  for (var ai = 0; ai < arcPtsStretched.length; ai++) {
    domeArcLen += dist(arcPrev, arcPtsStretched[ai]);
    arcPrev = arcPtsStretched[ai];
  }
  domeArcLen += dist(arcPrev, sP);

  var arcMidPt = arcPtsStretched[Math.floor(arcPtsStretched.length / 2)];

  // --- Area via Shoelace formula on full polygon (with arc) ---
  var area = 0;
  for (var i = 0; i < pts.length; i++) {
    var j = (i + 1) % pts.length;
    area += pts[i][0] * pts[j][1];
    area -= pts[j][0] * pts[i][1];
  }
  area = Math.abs(area) / 2;

  return {
    points: pts,
    mainVerts: mainVerts,
    sP: sP, sW: sW, sW2: sW2, sPost: sPost, sW3: sW3,
    edgePW: edgePW,
    edgeWW2: edgeWW2,
    edgeW2Post: edgeW2Post,
    edgePostW3: edgePostW3,
    domeArcLen: domeArcLen,
    arcMidPt: arcMidPt,
    area: area,
    stretchFactor: stretchFactor
  };
}

// ===================================================================
// Drawing Utilities
// ===================================================================
function setupCanvas(canvas) {
  var dpr = window.devicePixelRatio || 1;
  var rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  var ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { ctx: ctx, w: rect.width, h: rect.height };
}

function makeTransform(w, h, xMin, xMax, yMin, yMax) {
  var padX = 0.08 * w, padY = 0.08 * h;
  var drawW = w - 2 * padX;
  var drawH = h - 2 * padY;
  var scaleX = drawW / (xMax - xMin);
  var scaleY = drawH / (yMax - yMin);
  var scale = Math.min(scaleX, scaleY);
  var offsetX = padX + (drawW - scale * (xMax - xMin)) / 2;
  var offsetY = padY + (drawH - scale * (yMax - yMin)) / 2;
  return {
    tx: function(x) { return offsetX + (x - xMin) * scale; },
    ty: function(y) { return h - (offsetY + (y - yMin) * scale); },
    scale: scale
  };
}

// ===================================================================
// Panel Renderer
// ===================================================================
function drawPanel(g) {
  var canvas = document.getElementById('panel');
  var setup = setupCanvas(canvas);
  var ctx = setup.ctx, w = setup.w, h = setup.h;
  var panel = computeUnfoldedPanel(g);
  var pts = panel.points;

  // Bounding box with padding
  var xs = pts.map(function(p) { return p[0]; });
  var ys = pts.map(function(p) { return p[1]; });
  var xMin = Math.min.apply(null, xs) - 6;
  var xMax = Math.max.apply(null, xs) + 6;
  var yMin = Math.min.apply(null, ys) - 6;
  var yMax = Math.max.apply(null, ys) + 5;
  var t = makeTransform(w, h, xMin, xMax, yMin, yMax);

  // Background
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, w, h);

  // Light grid
  ctx.strokeStyle = '#e8e8e8';
  ctx.lineWidth = 0.5;
  var gridStep = 5;
  for (var gx = Math.ceil(xMin / gridStep) * gridStep; gx <= xMax; gx += gridStep) {
    ctx.beginPath();
    ctx.moveTo(t.tx(gx), t.ty(yMin));
    ctx.lineTo(t.tx(gx), t.ty(yMax));
    ctx.stroke();
  }
  for (var gy = Math.ceil(yMin / gridStep) * gridStep; gy <= yMax; gy += gridStep) {
    ctx.beginPath();
    ctx.moveTo(t.tx(xMin), t.ty(gy));
    ctx.lineTo(t.tx(xMax), t.ty(gy));
    ctx.stroke();
  }

  // Fill panel shape
  ctx.beginPath();
  ctx.moveTo(t.tx(pts[0][0]), t.ty(pts[0][1]));
  for (var i = 1; i < pts.length; i++) {
    ctx.lineTo(t.tx(pts[i][0]), t.ty(pts[i][1]));
  }
  ctx.closePath();
  ctx.fillStyle = 'rgba(52, 152, 219, 0.12)';
  ctx.fill();

  // Stroke panel outline
  ctx.beginPath();
  ctx.moveTo(t.tx(pts[0][0]), t.ty(pts[0][1]));
  for (var i = 1; i < pts.length; i++) {
    ctx.lineTo(t.tx(pts[i][0]), t.ty(pts[i][1]));
  }
  ctx.closePath();
  ctx.strokeStyle = '#2c3e50';
  ctx.lineWidth = 2.5;
  ctx.stroke();

  // Interior wing room boundary (dashed line from W2 to W3)
  ctx.beginPath();
  ctx.moveTo(t.tx(panel.sW2[0]), t.ty(panel.sW2[1]));
  ctx.lineTo(t.tx(panel.sW3[0]), t.ty(panel.sW3[1]));
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([6, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Area labels: "Wing Room" and "Extension"
  var wrcX = (panel.sP[0] + panel.sW[0] + panel.sW2[0] + panel.sW3[0]) / 4;
  var wrcY = (panel.sP[1] + panel.sW[1] + panel.sW2[1] + panel.sW3[1]) / 4;
  ctx.font = '13px -apple-system, sans-serif';
  ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Wing Room', t.tx(wrcX), t.ty(wrcY));

  var excX = (panel.sW2[0] + panel.sPost[0] + panel.sW3[0]) / 3;
  var excY = (panel.sW2[1] + panel.sPost[1] + panel.sW3[1]) / 3;
  ctx.fillText('Extension', t.tx(excX), t.ty(excY));

  // Centroid from 5 main vertices (not arc points) for label offsets
  var mv = panel.mainVerts;
  var cx = 0, cy = 0;
  for (var k = 0; k < mv.length; k++) { cx += mv[k][0]; cy += mv[k][1]; }
  cx /= mv.length; cy /= mv.length;

  // Edge definitions (4 straight edges; dome arc handled separately)
  var edges = [
    { from: 0, to: 1, len: panel.edgePW, label: 'Back wall (ridge)', color: '#2c3e50' },
    { from: 1, to: 2, len: panel.edgeWW2, label: 'Wing wall', color: '#8e44ad' },
    { from: 2, to: 3, len: panel.edgeW2Post, label: 'Extension', color: '#d35400' },
    { from: 3, to: 4, len: panel.edgePostW3, label: 'Bottom wall', color: '#c0392b' }
  ];

  for (var e = 0; e < edges.length; e++) {
    var edge = edges[e];
    var p1 = pts[edge.from];
    var p2 = pts[edge.to];
    var mx = (p1[0] + p2[0]) / 2;
    var my = (p1[1] + p2[1]) / 2;
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var edgeLen = Math.sqrt(dx * dx + dy * dy);
    if (edgeLen < 0.001) continue;

    // Perpendicular normal pointing away from polygon center
    var nx = -dy / edgeLen;
    var ny = dx / edgeLen;
    var toCenter = (cx - mx) * nx + (cy - my) * ny;
    if (toCenter > 0) { nx = -nx; ny = -ny; }

    var labelOff = 2.5;

    // Hash marks at endpoints
    var hashLen = 0.6;
    ctx.strokeStyle = edge.color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(t.tx(p1[0] + nx * hashLen), t.ty(p1[1] + ny * hashLen));
    ctx.lineTo(t.tx(p1[0] - nx * hashLen), t.ty(p1[1] - ny * hashLen));
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(t.tx(p2[0] + nx * hashLen), t.ty(p2[1] + ny * hashLen));
    ctx.lineTo(t.tx(p2[0] - nx * hashLen), t.ty(p2[1] - ny * hashLen));
    ctx.stroke();

    // Dimension line offset from edge
    var dimOff = 1.2;
    ctx.beginPath();
    ctx.moveTo(t.tx(p1[0] + nx * dimOff), t.ty(p1[1] + ny * dimOff));
    ctx.lineTo(t.tx(p2[0] + nx * dimOff), t.ty(p2[1] + ny * dimOff));
    ctx.strokeStyle = edge.color;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Arrowheads on dimension line
    var sx1 = t.tx(p1[0] + nx * dimOff), sy1 = t.ty(p1[1] + ny * dimOff);
    var sx2 = t.tx(p2[0] + nx * dimOff), sy2 = t.ty(p2[1] + ny * dimOff);
    var aAngle = Math.atan2(sy2 - sy1, sx2 - sx1);
    var headLen = 7;
    ctx.strokeStyle = edge.color;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(sx1, sy1);
    ctx.lineTo(sx1 + headLen * Math.cos(aAngle - 0.4), sy1 + headLen * Math.sin(aAngle - 0.4));
    ctx.moveTo(sx1, sy1);
    ctx.lineTo(sx1 + headLen * Math.cos(aAngle + 0.4), sy1 + headLen * Math.sin(aAngle + 0.4));
    ctx.stroke();
    var aAngle2 = aAngle + Math.PI;
    ctx.beginPath();
    ctx.moveTo(sx2, sy2);
    ctx.lineTo(sx2 + headLen * Math.cos(aAngle2 - 0.4), sy2 + headLen * Math.sin(aAngle2 - 0.4));
    ctx.moveTo(sx2, sy2);
    ctx.lineTo(sx2 + headLen * Math.cos(aAngle2 + 0.4), sy2 + headLen * Math.sin(aAngle2 + 0.4));
    ctx.stroke();

    // Length label
    var lx = mx + nx * labelOff;
    var ly = my + ny * labelOff;
    var rotation = Math.atan2(dy, dx);
    if (rotation > Math.PI / 2 || rotation < -Math.PI / 2) rotation += Math.PI;
    ctx.save();
    ctx.translate(t.tx(lx), t.ty(ly));
    ctx.rotate(-rotation);
    ctx.font = 'bold 13px -apple-system, sans-serif';
    ctx.fillStyle = edge.color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(edge.len.toFixed(1) + "'", 0, 0);
    ctx.restore();

    // Edge name label (further out)
    var nlx = mx + nx * (labelOff + 1.6);
    var nly = my + ny * (labelOff + 1.6);
    ctx.save();
    ctx.translate(t.tx(nlx), t.ty(nly));
    ctx.rotate(-rotation);
    ctx.font = '10px -apple-system, sans-serif';
    ctx.fillStyle = '#888';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(edge.label, 0, 0);
    ctx.restore();
  }

  // Dome arc label (curved edge, handled separately from straight edges)
  if (panel.arcMidPt) {
    var amp = panel.arcMidPt;
    // Normal at arc midpoint: point away from centroid
    var anx = amp[0] - cx, any = amp[1] - cy;
    var anLen = Math.sqrt(anx * anx + any * any);
    if (anLen > 0.001) { anx /= anLen; any /= anLen; }
    var domeColor = '#16a085';
    var dLabelOff = 2.5;
    // Length label
    ctx.font = 'bold 13px -apple-system, sans-serif';
    ctx.fillStyle = domeColor;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(panel.domeArcLen.toFixed(1) + "' arc", t.tx(amp[0] + anx * dLabelOff), t.ty(amp[1] + any * dLabelOff));
    // Name label
    ctx.font = '10px -apple-system, sans-serif';
    ctx.fillStyle = '#888';
    ctx.fillText('Dome side (curved)', t.tx(amp[0] + anx * (dLabelOff + 1.6)), t.ty(amp[1] + any * (dLabelOff + 1.6)));
  }

  // Corner dots and labels
  var cornerNames = ['P', 'W', 'W2', 'Post', 'W3'];
  var cornerDescs = ['dome conn (20\')', 'back wall end (20\')', 'wing wall (12\')', 'outer post (8\')', 'dome intersect (12\')'];
  var cornerColors = ['#27ae60', '#2c3e50', '#8e44ad', '#d35400', '#16a085'];

  for (var c = 0; c < 5; c++) {
    var pt = mv[c];
    // Dot
    ctx.beginPath();
    ctx.arc(t.tx(pt[0]), t.ty(pt[1]), 5, 0, 2 * Math.PI);
    ctx.fillStyle = cornerColors[c];
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Bisector direction for label placement
    var prev = mv[(c + 4) % 5];
    var next = mv[(c + 1) % 5];
    var toPrev = [prev[0] - pt[0], prev[1] - pt[1]];
    var toNext = [next[0] - pt[0], next[1] - pt[1]];
    var lPrev = Math.sqrt(toPrev[0] * toPrev[0] + toPrev[1] * toPrev[1]);
    var lNext = Math.sqrt(toNext[0] * toNext[0] + toNext[1] * toNext[1]);
    if (lPrev > 0.001) { toPrev[0] /= lPrev; toPrev[1] /= lPrev; }
    if (lNext > 0.001) { toNext[0] /= lNext; toNext[1] /= lNext; }
    var bisX = toPrev[0] + toNext[0];
    var bisY = toPrev[1] + toNext[1];
    var bisLen = Math.sqrt(bisX * bisX + bisY * bisY);
    if (bisLen < 0.001) { bisX = -toPrev[1]; bisY = toPrev[0]; bisLen = 1; }
    bisX /= bisLen; bisY /= bisLen;
    // Point away from centroid
    var toCent = (cx - pt[0]) * bisX + (cy - pt[1]) * bisY;
    if (toCent > 0) { bisX = -bisX; bisY = -bisY; }

    var off = 2.8;
    ctx.font = 'bold 12px -apple-system, sans-serif';
    ctx.fillStyle = cornerColors[c];
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(cornerNames[c], t.tx(pt[0] + bisX * off), t.ty(pt[1] + bisY * off));

    ctx.font = '9px -apple-system, sans-serif';
    ctx.fillStyle = '#999';
    ctx.fillText(cornerDescs[c], t.tx(pt[0] + bisX * (off + 1.3)), t.ty(pt[1] + bisY * (off + 1.3)));
  }

  // Title
  ctx.font = 'bold 14px -apple-system, sans-serif';
  ctx.fillStyle = '#333';
  ctx.textAlign = 'center';
  ctx.fillText('Wing Roof Panel \u2014 True Surface Dimensions', w / 2, 22);

  // Subtitle
  ctx.font = '11px -apple-system, sans-serif';
  ctx.fillStyle = '#888';
  ctx.fillText('Pitch: ' + g.pitchDeg.toFixed(1) + '\u00B0  |  Stretch: \u00D7' + panel.stretchFactor.toFixed(3) + '  |  Area: ' + panel.area.toFixed(0) + ' sq ft', w / 2, 40);

  // Footer
  ctx.font = '10px -apple-system, sans-serif';
  ctx.fillStyle = '#999';
  ctx.textAlign = 'left';
  ctx.fillText('Plan-view shape stretched by 1/cos(pitch) perpendicular to back wall.  Dome edge follows dome curvature.', 12, h - 8);

  // Update summary
  document.getElementById('sum-back').textContent = panel.edgePW.toFixed(1) + "'";
  document.getElementById('sum-wing').textContent = panel.edgeWW2.toFixed(1) + "'";
  document.getElementById('sum-ext').textContent = panel.edgeW2Post.toFixed(1) + "'";
  document.getElementById('sum-bottom').textContent = panel.edgePostW3.toFixed(1) + "'";
  document.getElementById('sum-dome').textContent = panel.domeArcLen.toFixed(1) + "' arc";
  document.getElementById('sum-area').textContent = panel.area.toFixed(0) + ' sf';

  // Material summary
  var waste = panel.area * 0.10;
  var total = panel.area + waste;
  document.getElementById('mat-area').textContent = panel.area.toFixed(0);
  document.getElementById('mat-waste').textContent = waste.toFixed(0);
  document.getElementById('mat-total').textContent = total.toFixed(0);
  document.getElementById('mat-squares').textContent = (total / 100).toFixed(2);

  return panel;
}

// ===================================================================
// Update Loop
// ===================================================================
function update() {
  var pitchDeg = parseFloat(slider.value);
  var g = computeGeometry(pitchDeg);
  document.getElementById('pitch-value').textContent = pitchDeg.toFixed(1) + '\u00B0';
  drawPanel(g);
  history.replaceState(null, '', '#pitch=' + pitchDeg.toFixed(1));
}

// ===================================================================
// Export / Share
// ===================================================================
function exportPNG() {
  var canvas = document.getElementById('panel');
  canvas.toBlob(function(blob) {
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'roof-panel-' + slider.value + 'deg.png';
    a.click();
    URL.revokeObjectURL(url);
  });
}

function shareLink() {
  var url = window.location.href;
  navigator.clipboard.writeText(url).then(function() {
    var btns = document.querySelectorAll('.actions button');
    var btn = btns[1];
    var orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(function() { btn.textContent = orig; }, 1500);
  });
}

// ===================================================================
// Init
// ===================================================================
var slider = document.getElementById('pitch-slider');

// Restore from URL hash
var hashMatch = window.location.hash.match(/pitch=([\d.]+)/);
if (hashMatch) {
  var v = parseFloat(hashMatch[1]);
  if (v >= 20 && v <= 35) slider.value = v;
}

slider.addEventListener('input', update);
window.addEventListener('resize', update);

// Listen for pitch changes from parent (iframe sync)
window.addEventListener('message', function(e) {
  if (e.data && e.data.type === 'setPitch') {
    var v = parseFloat(e.data.value);
    if (v >= 20 && v <= 35) { slider.value = v; update(); }
  }
});

update();
</script>
</body>
</html>
