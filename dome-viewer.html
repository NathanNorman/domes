<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NSD Dome + Wing Architectural Visualizer</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #0a0a0f;
    color: #e0e0e8;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  #canvas-container {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 0;
  }

  canvas { display: block; }

  /* Control Panel */
  #controls-wrapper {
    position: fixed;
    top: 16px;
    left: 16px;
    z-index: 10;
    transition: transform 0.3s ease;
  }
  #controls-wrapper.hidden { transform: translateX(-100%); }

  #controls {
    width: 300px;
    max-height: calc(100vh - 32px);
    overflow-y: auto;
    background: rgba(15, 15, 25, 0.88);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 12px;
    padding: 20px;
    font-size: 13px;
  }

  /* Panel toggle buttons */
  .panel-toggle {
    position: absolute;
    width: 24px;
    height: 24px;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.15);
    background: rgba(15, 15, 25, 0.88);
    color: rgba(255,255,255,0.6);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    line-height: 1;
    padding: 0;
    transition: background 0.15s, color 0.15s;
  }
  .panel-toggle:hover { background: rgba(255,255,255,0.15); color: #fff; }

  #controls-toggle { top: 8px; right: -32px; }
  #info-panel-toggle { top: 8px; left: -32px; }

  #controls::-webkit-scrollbar { width: 4px; }
  #controls::-webkit-scrollbar-track { background: transparent; }
  #controls::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }

  #controls h2 {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 16px;
    color: #fff;
    letter-spacing: -0.3px;
  }

  .section {
    margin-bottom: 18px;
    padding-bottom: 14px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }

  .section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

  .section-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: rgba(255,255,255,0.4);
    margin-bottom: 10px;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 2px;
  }

  .control-row label {
    font-size: 12px;
    color: rgba(255,255,255,0.7);
    flex-shrink: 0;
  }

  .control-row .value {
    font-size: 12px;
    font-weight: 500;
    color: #fff;
    min-width: 60px;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }

  select {
    width: 100%;
    padding: 6px 8px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    color: #fff;
    font-size: 12px;
    margin-bottom: 8px;
    cursor: pointer;
    outline: none;
  }
  select:focus { border-color: rgba(100, 140, 255, 0.5); }

  input[type="range"] {
    width: 100%;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    outline: none;
    margin: 2px 0 14px 0;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #6888ff;
    cursor: pointer;
    border: 2px solid #0a0a0f;
  }

  .toggle-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
  }

  .toggle-row label {
    font-size: 12px;
    color: rgba(255,255,255,0.7);
  }

  .toggle {
    position: relative;
    width: 34px;
    height: 18px;
    flex-shrink: 0;
  }

  .toggle input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .toggle .slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(255,255,255,0.1);
    border-radius: 9px;
    transition: background 0.2s;
  }

  .toggle .slider::before {
    content: '';
    position: absolute;
    height: 12px;
    width: 12px;
    left: 3px;
    bottom: 3px;
    background: rgba(255,255,255,0.5);
    border-radius: 50%;
    transition: transform 0.2s, background 0.2s;
  }

  .toggle input:checked + .slider { background: rgba(100, 140, 255, 0.4); }
  .toggle input:checked + .slider::before { transform: translateX(16px); background: #6888ff; }

  /* Camera buttons */
  .camera-buttons {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    margin-top: 4px;
  }

  .camera-buttons button {
    flex: 1;
    min-width: 55px;
    padding: 5px 4px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    color: rgba(255,255,255,0.7);
    font-size: 11px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .camera-buttons button:hover {
    background: rgba(100, 140, 255, 0.15);
    border-color: rgba(100, 140, 255, 0.3);
    color: #fff;
  }

  /* Info Panel (bottom-right) */
  #info-panel-wrapper {
    position: fixed;
    bottom: 16px;
    right: 16px;
    z-index: 10;
    transition: transform 0.3s ease;
  }
  #info-panel-wrapper.hidden { transform: translateX(100%); }

  #info-panel {
    width: 320px;
    background: rgba(15, 15, 25, 0.88);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 12px;
    padding: 16px 20px;
    font-size: 13px;
  }

  #info-panel .info-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: rgba(255,255,255,0.4);
    margin-bottom: 10px;
  }

  .info-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
    font-size: 12px;
  }

  .info-row .info-label { color: rgba(255,255,255,0.5); }
  .info-row .info-value { color: #fff; font-weight: 500; font-variant-numeric: tabular-nums; }

  #status-badge {
    display: inline-block;
    padding: 3px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.5px;
    margin-top: 8px;
  }

  .status-fits { background: rgba(0, 180, 80, 0.2); color: #44dd88; border: 1px solid rgba(0, 180, 80, 0.3); }
  .status-collision { background: rgba(220, 40, 40, 0.2); color: #ff6666; border: 1px solid rgba(220, 40, 40, 0.3); }

  /* Riser snap indicators */
  .snap-marks {
    position: relative;
    height: 12px;
    margin-top: 2px;
    margin-bottom: 4px;
  }

  .snap-mark {
    position: absolute;
    font-size: 9px;
    color: rgba(255,255,255,0.3);
    transform: translateX(-50%);
    cursor: pointer;
  }

  .snap-mark:hover { color: rgba(255,255,255,0.7); }

  /* Title bar */
  #title-bar {
    position: fixed;
    top: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(15, 15, 25, 0.7);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    padding: 8px 20px;
    z-index: 10;
    font-size: 14px;
    font-weight: 500;
    color: rgba(255,255,255,0.8);
    pointer-events: none;
  }

  /* Legend */
  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 3px;
    font-size: 11px;
    color: rgba(255,255,255,0.5);
  }

  .legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  /* Cursor feedback for interactive edit modes */
  .cursor-grab canvas { cursor: grab !important; }
  .cursor-grabbing canvas { cursor: grabbing !important; }
  .cursor-crosshair canvas { cursor: crosshair !important; }
</style>
</head>
<body>

<div id="title-bar">NSD Dome + Wing Architectural Visualizer</div>

<div id="canvas-container"></div>
<img id="ref-overlay-img" style="display:none; position:fixed; pointer-events:none; opacity:0.5; z-index:5; max-width:none;">

<div id="controls-wrapper">
<button id="controls-toggle" class="panel-toggle" title="Hide controls">&lsaquo;</button>
<div id="controls">
  <h2>Controls</h2>

  <div class="section">
    <div class="section-title">Dome Configuration</div>
    <select id="dome-select">
      <option value="26M">26' Mid Profile</option>
      <option value="29M">29' Mid Profile</option>
      <option value="30L">30' Low Profile</option>
      <option value="30H">30' High Profile</option>
      <option value="33L">33' Low Profile</option>
      <option value="33H" selected>33' High Profile</option>
      <option value="36L">36' Low Profile</option>
      <option value="36H">36' High Profile</option>
      <option value="40L">40' Low Profile</option>
      <option value="40H">40' High Profile</option>
      <option value="45L">45' Low Profile</option>
      <option value="46M">46' Mid Profile</option>
      <option value="47L">47' Low Profile</option>
      <option value="49M">49' Mid Profile</option>
      <option value="50L">50' Low Profile</option>
      <option value="51M">51' Mid Profile</option>
    </select>
    <!-- Dome profile slider removed — profile is fixed per NSD model
    <div class="control-row">
      <label>Dome Profile</label>
      <span class="value" id="profile-value">59%</span>
    </div>
    <input type="range" id="profile-slider" min="25" max="75" value="59" step="1">
    -->
    <div class="toggle-row">
      <label>Octagonal Base</label>
      <label class="toggle"><input type="checkbox" id="octagonal-base"><span class="slider"></span></label>
    </div>
    <div class="control-row">
      <label>Wall Height</label>
      <span class="value" id="riser-value">28"</span>
    </div>
    <input type="range" id="riser-slider" min="0" max="120" value="28" step="0.5">
    <div class="snap-marks" id="riser-snaps"></div>
    <div class="control-row">
      <label>Total Height</label>
      <span class="value" id="total-height-value">--</span>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Wing Buildings</div>
    <div class="toggle-row">
      <label>Show Wings</label>
      <label class="toggle"><input type="checkbox" id="show-wings" checked><span class="slider"></span></label>
    </div>
    <div class="control-row">
      <label>Near Left Height</label>
      <span class="value" id="wing-hnl-value">8'-0"</span>
    </div>
    <input type="range" id="wing-hnl-slider" min="6" max="24" value="8" step="0.25">
    <div class="control-row">
      <label>Near Right Height</label>
      <span class="value" id="wing-hnr-value">21'-0"</span>
    </div>
    <input type="range" id="wing-hnr-slider" min="6" max="24" value="21" step="0.25">
    <div class="control-row">
      <label>Far Left Height</label>
      <span class="value" id="wing-hfl-value">8'-0"</span>
    </div>
    <input type="range" id="wing-hfl-slider" min="4" max="24" value="8" step="0.25">
    <div class="control-row">
      <label>Far Right Height</label>
      <span class="value" id="wing-hfr-value">21'-0"</span>
    </div>
    <input type="range" id="wing-hfr-slider" min="4" max="24" value="21" step="0.25">
    <div class="control-row">
      <label>Roof Overhang</label>
      <span class="value" id="roof-overhang-value">1'-0"</span>
    </div>
    <input type="range" id="roof-overhang-slider" min="0" max="8" value="1" step="0.25">
    <div class="control-row">
      <label>Wing Width</label>
      <span class="value" id="wing-width-value">16'-0"</span>
    </div>
    <input type="range" id="wing-width-slider" min="8" max="24" value="16" step="0.5">
    <div class="control-row">
      <label>Wing Angle</label>
      <span class="value" id="wing-angle-value">112&deg;</span>
    </div>
    <input type="range" id="wing-angle-slider" min="0" max="360" value="112" step="1">
    <div class="control-row">
      <label>Wing Depth</label>
      <span class="value" id="wing-depth-value">24'-0"</span>
    </div>
    <input type="range" id="wing-depth-slider" min="10" max="40" value="24" step="0.25">
    <div class="control-row">
      <label>Inner Wall Arc ⌀</label>
      <span class="value" id="wing-arc-value">100'-0"</span>
    </div>
    <input type="range" id="wing-arc-slider" min="0" max="500" value="100" step="5">
    <div class="control-row">
      <label>Canopy Depth</label>
      <span class="value" id="canopy-depth-value">6'-0"</span>
    </div>
    <input type="range" id="canopy-depth-slider" min="3" max="10" value="6" step="0.5">
    <div class="toggle-row">
      <label>Show Canopy</label>
      <label class="toggle"><input type="checkbox" id="show-canopy"><span class="slider"></span></label>
    </div>
    <div class="section-title">Entry Box</div>
    <div class="control-row">
      <label>Entry Width</label>
      <span class="value" id="entry-width-value">8'-0"</span>
    </div>
    <input type="range" id="entry-width-slider" min="4" max="12" value="8" step="0.5">
    <div class="control-row">
      <label>Entry Depth</label>
      <span class="value" id="entry-depth-value">5'-0"</span>
    </div>
    <input type="range" id="entry-depth-slider" min="3" max="8" value="5" step="0.5">
    <div class="control-row">
      <label>Entry Roof</label>
      <span class="value" id="entry-roof-value">Flat</span>
    </div>
    <select id="entry-roof-select" style="width:100%;padding:4px;margin-bottom:8px;background:#1a1a2e;color:#e0e0e8;border:1px solid rgba(255,255,255,0.15);border-radius:4px;">
      <option value="flat">Flat</option>
      <option value="sloped">Sloped to front</option>
      <option value="gable">Gable (peaked)</option>
    </select>
    <div class="toggle-row">
      <label>Connect Wings to Entry</label>
      <label class="toggle"><input type="checkbox" id="connect-wings-to-entry"><span class="slider"></span></label>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Interior</div>
    <div class="toggle-row">
      <label>Show Interior</label>
      <label class="toggle"><input type="checkbox" id="show-interior" checked><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Show Room Labels</label>
      <label class="toggle"><input type="checkbox" id="show-room-labels" checked><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Cutaway Mode</label>
      <label class="toggle"><input type="checkbox" id="cutaway-mode"><span class="slider"></span></label>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Display</div>
    <div class="toggle-row">
      <label>Wireframe</label>
      <label class="toggle"><input type="checkbox" id="show-wireframe"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Height Markers</label>
      <label class="toggle"><input type="checkbox" id="show-markers"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Vertex Labels</label>
      <label class="toggle"><input type="checkbox" id="show-vertex-labels"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Width-at-Height Ring</label>
      <label class="toggle"><input type="checkbox" id="show-width-ring"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Ground Grid</label>
      <label class="toggle"><input type="checkbox" id="show-grid"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Show Dimensions</label>
      <label class="toggle"><input type="checkbox" id="show-dimensions"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Outdoor Environment</label>
      <label class="toggle"><input type="checkbox" id="outdoor-env" checked><span class="slider"></span></label>
    </div>
    <div class="control-row">
      <label>Dome Opacity</label>
      <span class="value" id="opacity-value">30%</span>
    </div>
    <input type="range" id="opacity-slider" min="10" max="100" value="30" step="5">
  </div>

  <div class="section">
    <div class="section-title">Interactive Edit</div>
    <div class="toggle-row">
      <label>Edit Mode</label>
      <label class="toggle"><input type="checkbox" id="edit-mode"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Draw Rooms</label>
      <label class="toggle"><input type="checkbox" id="draw-rooms"><span class="slider"></span></label>
    </div>
    <div class="toggle-row">
      <label>Walk Mode</label>
      <label class="toggle"><input type="checkbox" id="walk-mode"><span class="slider"></span></label>
    </div>
    <div class="toggle-row" id="camera-view-row" style="display:none">
      <label>First Person</label>
      <label class="toggle"><input type="checkbox" id="first-person"><span class="slider"></span></label>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Camera Presets</div>
    <div class="camera-buttons">
      <button onclick="setCameraPreset('front')">Front</button>
      <button onclick="setCameraPreset('side')">Side</button>
      <button onclick="setCameraPreset('top')">Top</button>
      <button onclick="setCameraPreset('quarter')">3/4 View</button>
      <button onclick="setCameraPreset('drawing')">Drawing</button>
    </div>
    <div class="toggle-row">
      <label>Orthographic</label>
      <label class="toggle"><input type="checkbox" id="ortho-camera"><span class="slider"></span></label>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Save / Load</div>
    <div class="camera-buttons">
      <button id="export-state">Export</button>
      <button id="import-state">Load</button>
    </div>
    <input type="file" id="import-file" accept=".json" style="display:none">
  </div>

  <div class="section">
    <div class="camera-buttons">
      <button id="screenshot-mode-btn">Screenshot Mode</button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Reference Overlay</div>
    <div class="camera-buttons" style="margin-bottom:8px">
      <button id="ref-overlay-load">Load Image</button>
      <button id="ref-overlay-clear">Clear</button>
      <button id="ref-overlay-lock">Lock</button>
    </div>
    <input type="file" id="ref-overlay-file" accept="image/*" style="display:none">
    <div class="control-row">
      <label>Opacity</label>
      <span class="value" id="ref-overlay-opacity-value">50%</span>
    </div>
    <input type="range" id="ref-overlay-opacity" min="0" max="100" value="50" step="5">
    <div class="control-row">
      <label>Scale Adjust</label>
      <span class="value" id="ref-overlay-scale-value">100%</span>
    </div>
    <input type="range" id="ref-overlay-scale" min="50" max="200" value="100" step="1">
  </div>

  <div class="section">
    <div class="section-title">Legend</div>
    <div class="legend-item"><div class="legend-dot" style="background: rgba(100,140,255,0.7);"></div>Dome Shell</div>
    <div class="legend-item"><div class="legend-dot" style="background: #888;"></div>Riser Wall</div>
    <div class="legend-item"><div class="legend-dot" style="background: #d4c4a0;"></div>Wing Walls</div>
    <div class="legend-item"><div class="legend-dot" style="background: #4a3a2a;"></div>Wing Roof</div>
    <div class="legend-item"><div class="legend-dot" style="background: #44dd88;"></div>Wing (fits)</div>
    <div class="legend-item"><div class="legend-dot" style="background: #ff6666;"></div>Wing (collision)</div>
    <div class="legend-item"><div class="legend-dot" style="background: #ffaa22;"></div>Dome Width at Wing Top</div>
    <div class="legend-item"><div class="legend-dot" style="background: #8b6914;"></div>Corner Posts</div>
    <div class="legend-item"><div class="legend-dot" style="background: #ffcc00;"></div>Edit Handles</div>
    <div class="legend-item"><div class="legend-dot" style="background: #66aaff;"></div>Wall Endpoints</div>
  </div>
</div>
</div>

<div id="info-panel-wrapper">
<button id="info-panel-toggle" class="panel-toggle" title="Hide panel">&rsaquo;</button>
<div id="info-panel">
  <div class="info-title">Collision Analysis</div>
  <div class="info-row"><span class="info-label">Dome Width at Wing Top</span><span class="info-value" id="info-dome-width">--</span></div>
  <div class="info-row"><span class="info-label">Required Width</span><span class="info-value" id="info-req-width">--</span></div>
  <div class="info-row"><span class="info-label">Clearance per Side</span><span class="info-value" id="info-clearance">--</span></div>
  <div class="info-row"><span class="info-label">Min Riser for Fit</span><span class="info-value" id="info-min-riser">--</span></div>
  <div class="info-row"><span class="info-label">Total Area</span><span class="info-value" id="info-total-area">--</span></div>
  <div id="status-badge" class="status-collision">COLLISION</div>
</div>
</div>

<!-- Three.js from CDN -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Early state declarations needed before DOME_CONFIGS init
// let domeProfileRatio = 0.5938;  // REMOVED — profile is now fixed per NSD model
let octagonalBase = false;
let octSideFractions = [1,1,1,1,1,1,1,1]; // multiplier of default apothem per side

// ============================================================
// DOME CONFIGURATIONS — Real NSD (Natural Spaces Domes) specs
// Shell heights computed from NSD published total height minus riser height.
// sphereRadius = (baseRadius² + shellHeight²) / (2 * shellHeight)
// ============================================================
function makeDomeCfg(diameter, shellHeight, defaultRiserIn, riserOptions, label) {
  const baseRadius = diameter / 2;
  const sphereRadius = (baseRadius * baseRadius + shellHeight * shellHeight) / (2 * shellHeight);
  return { diameter, baseRadius, shellHeight, sphereRadius, defaultRiserIn, riserOptions, label };
}

const DOME_CONFIGS = {
  // 26' Mid Profile: total 16'11.5", riser 4'0" → shell 12.96'
  '26M':  makeDomeCfg(26,  12.96, 48, [0, 48],           "26' Mid"),
  // 29' Mid Profile: total 18'6.75", riser 4'0" → shell 14.56'
  '29M':  makeDomeCfg(29,  14.56, 48, [0, 48],           "29' Mid"),
  // 30' Low Profile: total 15'11.25", riser 3'9" → shell 12.19'
  '30L':  makeDomeCfg(30,  12.19, 45, [0, 45],           "30' Low"),
  // 30' High Profile: total 20'3.75", riser 3'0" → shell 17.31'
  '30H':  makeDomeCfg(30,  17.31, 36, [0, 36],           "30' High"),
  // 33' Low Profile: interpolated from 30L/36L, riser 3'6" → shell ~13.30'
  '33L':  makeDomeCfg(33,  13.30, 42, [0, 42],            "33' Low"),
  // 33' High Profile: interpolated from 30H/36H, riser 2'4.5" → shell ~19.26'
  '33H':  makeDomeCfg(33,  19.26, 28, [0, 28],            "33' High"),
  // 36' Low Profile: total 18'2", riser 3'9" → shell 14.42'
  '36L':  makeDomeCfg(36,  14.42, 45, [0, 28, 38, 45],   "36' Low"),
  // 36' High Profile: total 23'7", riser 2'4.5" → shell 21.21'
  '36H':  makeDomeCfg(36,  21.21, 28, [0, 28, 38, 45],   "36' High"),
  // 40' Low Profile: total 19'11.5", riser 3'9" → shell 16.21'
  '40L':  makeDomeCfg(40,  16.21, 45, [0, 28, 45, 60],   "40' Low"),
  // 40' High Profile: total 26'2.5", riser 2'4.5" → shell 23.83'
  '40H':  makeDomeCfg(40,  23.83, 28, [0, 28, 45, 60],   "40' High"),
  // 45' Low Profile: total 20'6.75", riser 3'9" → shell 16.81'
  '45L':  makeDomeCfg(45,  16.81, 45, [0, 45, 60],       "45' Low"),
  // 46' Mid Profile: total 25'6.5", riser 2'4.5" → shell 23.17'
  '46M':  makeDomeCfg(46,  23.17, 28, [0, 28, 45, 60],   "46' Mid"),
  // 47' Low Profile: total 21'6.5", riser 3'9" → shell 17.79'
  '47L':  makeDomeCfg(47,  17.79, 45, [0, 45, 60],       "47' Low"),
  // 49' Mid Profile: total 26'8", riser 2'4.5" → shell 24.29'
  '49M':  makeDomeCfg(49,  24.29, 28, [0, 28, 45, 60],   "49' Mid"),
  // 50' Low Profile: total 21'10", riser 3'9" → shell 18.08'
  '50L':  makeDomeCfg(50,  18.08, 45, [0, 45, 60],       "50' Low"),
  // 51' Mid Profile: total 28'0", riser 2'4.5" → shell 25.63'
  '51M':  makeDomeCfg(51,  25.63, 28, [0, 28, 45, 60],   "51' Mid"),
};

// REMOVED — profile is now fixed per model; no need to recompute
// function updateDomeProfile() { ... }
// updateDomeProfile();

// ============================================================
// OCTAGONAL BASE HELPERS
// ============================================================
const OCT_N = 8;
const OCT_STEP = (2 * Math.PI) / OCT_N;

function octSideAngle(i) { return i * OCT_STEP; }

function getOctApothem(i, baseRadius) {
  return octSideFractions[i] * baseRadius * Math.cos(Math.PI / OCT_N);
}

// Octagonal radius at arbitrary angle phi
function octRadiusAtAngle(phi, baseRadius) {
  phi = ((phi % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
  const idx = Math.floor((phi + OCT_STEP / 2) / OCT_STEP) % OCT_N;
  const mid = octSideAngle(idx);
  const apothem = getOctApothem(idx, baseRadius);
  return apothem / Math.cos(phi - mid);
}

// Get octagon vertices (intersections of adjacent sides)
function getOctVertices(baseRadius) {
  const verts = [];
  for (let i = 0; i < OCT_N; i++) {
    const a1 = octSideAngle(i), d1 = getOctApothem(i, baseRadius);
    const a2 = octSideAngle((i + 1) % OCT_N), d2 = getOctApothem((i + 1) % OCT_N, baseRadius);
    const c1 = Math.cos(a1), s1 = Math.sin(a1);
    const c2 = Math.cos(a2), s2 = Math.sin(a2);
    const det = c1 * s2 - c2 * s1;
    verts.push({ x: (d1 * s2 - d2 * s1) / det, z: (c1 * d2 - c2 * d1) / det });
  }
  return verts;
}

// Get midpoint of octagon side (for handles)
function getOctSideMidpoint(i, baseRadius) {
  const angle = octSideAngle(i);
  const apothem = getOctApothem(i, baseRadius);
  return { x: apothem * Math.cos(angle), z: apothem * Math.sin(angle) };
}

// ============================================================
// STATE
// ============================================================
let currentDomeKey = '33H';
let riserHeightInches = 90;
// Four independent corner heights (wing local coords: -x=left, +x=right, z=0=near/dome, z=depth=far)
let wingHNL = 8;   // near-left (dome side, x=-hw)
let wingHNR = 21;  // near-right (dome side, x=+hw)
let wingHFL = 8;   // far-left
let wingHFR = 21;  // far-right
let roofOverhangFt = 1;     // roof overhang past lower wall edge(s)
let wingWidthFt = 16;
let wingAngleDeg = 112;
let wingDepthFt = 24;
let wingArcDiameter = 100;  // inner wall arc diameter in feet (0 = flat wall)
let showWings = true;
let canopyDepthFt = 6;    // radial depth extending outward from dome
let entryWidth = 8;       // entry box width in feet
let entryDepth = 5;       // entry box depth extending from dome
let entryRoofStyle = 'flat'; // 'flat', 'sloped', 'gable'
let showWireframe = false;
let showMarkers = false;
let showVertexLabels = false;
let showWidthRing = false;
let showGrid = true;
let showDimensions = false;
let showInterior = true;
let showRoomLabels = true;
let cutawayMode = false;
let outdoorEnv = true;
let showCanopy = false;
let connectWingsToEntry = false;
let domeOpacity = 0.3;

// Interactive edit state
let editMode = false;
let drawRoomsMode = false;
let walkMode = false;
let firstPersonView = false;

// Drag state
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragTarget = null;       // which handle mesh is being dragged
let dragPlane = null;        // invisible plane for projecting mouse movement
let dragStartPoint = null;   // world point where drag began
let dragStartValue = null;   // parameter value at drag start
let hoveredHandle = null;    // currently hovered handle

// Room drawing state
let customWalls = [];        // Array of {x1, z1, x2, z2, height, autoHeight, thickness}
let drawingWall = null;      // Partial wall being drawn {x1, z1}
let drawPreviewLine = null;  // Preview line while drawing

// Undo/Redo history
const undoStack = {
  snapshots: [],
  index: -1,
  maxSize: 50,
  _restoring: false,

  push(state) {
    if (this._restoring) return;
    // Trim future history on new change
    this.snapshots = this.snapshots.slice(0, this.index + 1);
    this.snapshots.push(state);
    this.index++;
    if (this.snapshots.length > this.maxSize) {
      this.snapshots.shift();
      this.index--;
    }
  },

  undo() {
    if (this.index <= 0) return null;
    this.index--;
    return this.snapshots[this.index];
  },

  redo() {
    if (this.index >= this.snapshots.length - 1) return null;
    this.index++;
    return this.snapshots[this.index];
  },

  canUndo() { return this.index > 0; },
  canRedo() { return this.index < this.snapshots.length - 1; },
};
let _undoDebounceTimer = null;

// ============================================================
// THREE.JS SETUP
// ============================================================
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();

let camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
const perspCamera = camera;
const orthoCamera = new THREE.OrthographicCamera(-50, 50, 50, -50, 0.1, 1000);
let useOrthoCamera = true;
camera.position.set(0, 60, 0.1);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.localClippingEnabled = true;
container.appendChild(renderer.domElement);

const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.enableDamping = true;
orbitControls.dampingFactor = 0.08;
orbitControls.target.set(0, 0, 0);
orbitControls.minDistance = 10;
orbitControls.maxDistance = 200;
orbitControls.maxPolarAngle = Math.PI * 0.85;

// ============================================================
// AGENT API — window._dome
// ============================================================
// Exposed for agent-browser automation. Usage from agent-browser eval:
//
//   agent-browser eval "JSON.stringify(window._dome.inspect())"
//   agent-browser eval "window._dome.preset('top')"
//   agent-browser eval "window._dome.setCamera(0, 60, 0.1, 0, 0, 0)"
//   agent-browser eval "window._dome.set('wingAngle', 90)"
//   agent-browser eval "window._dome.presets"
//   agent-browser eval "window._dome.params"
//
// inspect() returns a JSON-serializable summary of the scene state.
// set(param, value) changes a parameter, syncs UI, and triggers a full rebuild.
// presets/params arrays list valid names for preset() and set() respectively.
// ============================================================
window._dome = {
  // Core Three.js objects
  camera, scene, renderer, orbitControls,

  // Scene groups (lazy getters for module-scoped vars)
  get wingL() { return wingGroupL; },
  get wingR() { return wingGroupR; },
  get canopyL() { return canopyWrapL; },
  get canopyR() { return canopyWrapR; },
  get domeGroup() { return domeGroup; },
  get postGroup() { return postGroup; },
  get interiorGroup() { return interiorGroup; },
  get entryBox() { return entryBoxGroup; },

  // Camera helpers
  setCamera(x, y, z, tx, ty, tz) {
    camera.position.set(x, y, z);
    if (tx !== undefined) orbitControls.target.set(tx, ty, tz);
    orbitControls.update();
  },
  preset(name) { setCameraPreset(name); },
  presets: ['front', 'side', 'top', 'quarter', 'drawing', 'entry', 'canopy-top', 'bird'],
  models: Object.keys(DOME_CONFIGS),
  params: ['dome', 'octagonalBase', 'riser', 'domeOpacity', 'wingAngle', 'wingWidth', 'wingDepth', 'wingHNL', 'wingHNR', 'wingHFL', 'wingHFR', 'roofOverhang', 'wingArc', 'canopyDepth', 'showCanopy', 'entryWidth', 'entryDepth', 'entryRoofStyle', 'connectWingsToEntry', 'showWings', 'showWireframe', 'showMarkers', 'showVertexLabels', 'showWidthRing', 'showGrid', 'showDimensions', 'showInterior', 'showRoomLabels', 'cutaway', 'outdoorEnv', 'orthoCamera'],

  // Scene inspection — returns JSON-serializable state
  inspect() {
    const cfg = DOME_CONFIGS[currentDomeKey];
    const riserFt = riserHeightInches / 12;
    return {
      dome: { key: currentDomeKey, label: cfg.label, diameter: cfg.diameter, riserFt, octagonalBase },
      wings: {
        show: showWings,
        angle: wingAngleDeg, width: wingWidthFt, depth: wingDepthFt,
        hNL: wingHNL, hNR: wingHNR, hFL: wingHFL, hFR: wingHFR,
        arcDiameter: wingArcDiameter, roofOverhang: roofOverhangFt,
        hasL: !!wingGroupL, hasR: !!wingGroupR,
        childrenL: wingGroupL ? wingGroupL.children.length : 0,
        childrenR: wingGroupR ? wingGroupR.children.length : 0,
      },
      canopy: {
        show: showCanopy, depth: canopyDepthFt, entryWidth, entryDepth, entryRoofStyle, connectWingsToEntry,
        hasL: !!canopyWrapL, hasR: !!canopyWrapR,
        childrenL: canopyWrapL ? canopyWrapL.children.length : 0,
        childrenR: canopyWrapR ? canopyWrapR.children.length : 0,
      },
      camera: {
        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
        target: { x: orbitControls.target.x, y: orbitControls.target.y, z: orbitControls.target.z },
      },
      display: { wireframe: showWireframe, markers: showMarkers, vertexLabels: showVertexLabels, widthRing: showWidthRing, grid: showGrid, dimensions: showDimensions, interior: showInterior, roomLabels: showRoomLabels, cutaway: cutawayMode, outdoorEnv, domeOpacity },
    };
  },

  // Rebuild trigger (for parameter changes via agent)
  rebuild() { rebuildScene(); },

  // Parameter setters (change state + sync UI + rebuild)
  set(param, value) {
    const el = id => document.getElementById(id);
    const setters = {
      // Dome
      dome: v => { if (!DOME_CONFIGS[v]) throw new Error('Unknown dome "' + v + '". Valid: ' + Object.keys(DOME_CONFIGS).join(', ')); currentDomeKey = v; el('dome-select').value = v; const c = DOME_CONFIGS[v]; if (c.defaultRiserIn !== undefined) { riserHeightInches = c.defaultRiserIn; el('riser-slider').value = riserHeightInches; el('riser-value').textContent = riserHeightInches + '"'; } updateRiserSnaps(); },
      octagonalBase: v => { octagonalBase = v; el('octagonal-base').checked = v; },
      riser: v => { riserHeightInches = v; el('riser-slider').value = v; el('riser-value').textContent = v + '"'; },
      domeOpacity: v => { domeOpacity = v; el('opacity-slider').value = v * 100; el('opacity-value').textContent = Math.round(v * 100) + '%'; domeMaterial.opacity = v; domeMaterial.transparent = v < 0.95; domeMaterial.depthWrite = v >= 0.95; },
      // Wings
      wingAngle: v => { wingAngleDeg = v; el('wing-angle-slider').value = v; el('wing-angle-value').innerHTML = v + '&deg;'; },
      wingWidth: v => { wingWidthFt = v; el('wing-width-slider').value = v; el('wing-width-value').textContent = fmtFtIn(v); },
      wingDepth: v => { wingDepthFt = v; el('wing-depth-slider').value = v; el('wing-depth-value').textContent = fmtFtIn(v); },
      wingHNL: v => { wingHNL = v; el('wing-hnl-slider').value = v; el('wing-hnl-value').textContent = fmtFtIn(v); },
      wingHNR: v => { wingHNR = v; el('wing-hnr-slider').value = v; el('wing-hnr-value').textContent = fmtFtIn(v); },
      wingHFL: v => { wingHFL = v; el('wing-hfl-slider').value = v; el('wing-hfl-value').textContent = fmtFtIn(v); },
      wingHFR: v => { wingHFR = v; el('wing-hfr-slider').value = v; el('wing-hfr-value').textContent = fmtFtIn(v); },
      roofOverhang: v => { roofOverhangFt = v; el('roof-overhang-slider').value = v; el('roof-overhang-value').textContent = fmtFtIn(v); },
      wingArc: v => { wingArcDiameter = v; el('wing-arc-slider').value = v; el('wing-arc-value').textContent = v === 0 ? 'Dome' : fmtFtIn(v); },
      // Canopy
      canopyDepth: v => { canopyDepthFt = v; el('canopy-depth-slider').value = v; el('canopy-depth-value').textContent = fmtFtIn(v); },
      showCanopy: v => { showCanopy = v; el('show-canopy').checked = v; },
      entryWidth: v => { entryWidth = v; el('entry-width-slider').value = v; el('entry-width-value').textContent = fmtFtIn(v); },
      entryDepth: v => { entryDepth = v; el('entry-depth-slider').value = v; el('entry-depth-value').textContent = fmtFtIn(v); },
      entryRoofStyle: v => { entryRoofStyle = v; el('entry-roof-select').value = v; const s = el('entry-roof-select'); el('entry-roof-value').textContent = s.options[s.selectedIndex].text; },
      connectWingsToEntry: v => { connectWingsToEntry = v; el('connect-wings-to-entry').checked = v; },
      // Display toggles
      showWings: v => { showWings = v; el('show-wings').checked = v; },
      showWireframe: v => { showWireframe = v; el('show-wireframe').checked = v; },
      showMarkers: v => { showMarkers = v; el('show-markers').checked = v; },
      showVertexLabels: v => { showVertexLabels = v; el('show-vertex-labels').checked = v; },
      showWidthRing: v => { showWidthRing = v; el('show-width-ring').checked = v; },
      showGrid: v => { showGrid = v; el('show-grid').checked = v; if (gridHelper) gridHelper.visible = v; },
      showDimensions: v => { showDimensions = v; el('show-dimensions').checked = v; },
      showInterior: v => { showInterior = v; el('show-interior').checked = v; domeMaterial.opacity = v ? Math.min(domeOpacity, 0.3) : domeOpacity; },
      showRoomLabels: v => { showRoomLabels = v; el('show-room-labels').checked = v; },
      cutaway: v => { cutawayMode = v; el('cutaway-mode').checked = v; },
      outdoorEnv: v => { outdoorEnv = v; el('outdoor-env').checked = v; setupEnvironment(); },
      orthoCamera: v => { setOrthoMode(v); el('ortho-camera').checked = v; },
    };
    if (setters[param]) { setters[param](value); rebuildScene(); return true; }
    return 'Unknown param "' + param + '". Valid: ' + Object.keys(setters).join(', ');
  },

  // Undo/Redo
  undo() { const s = undoStack.undo(); if (s) { undoStack._restoring = true; importState(s); undoStack._restoring = false; return true; } return false; },
  redo() { const s = undoStack.redo(); if (s) { undoStack._restoring = true; importState(s); undoStack._restoring = false; return true; } return false; },
  get undoDepth() { return undoStack.index; },
  get redoDepth() { return undoStack.snapshots.length - 1 - undoStack.index; },
};

// Clipping plane for cutaway mode (clips the front half)
const cutawayPlane = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0);

// ============================================================
// LIGHTING
// ============================================================
let ambientLight, hemiLight, dirLight, fillLight;

function setupOutdoorLighting() {
  if (ambientLight) { scene.remove(ambientLight); scene.remove(hemiLight); scene.remove(dirLight); scene.remove(fillLight); }

  ambientLight = new THREE.AmbientLight(0x87CEEB, 0.5);
  scene.add(ambientLight);

  hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3a7a2a, 0.6);
  scene.add(hemiLight);

  dirLight = new THREE.DirectionalLight(0xfff4e0, 1.8);
  dirLight.position.set(40, 60, 30);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.left = -60;
  dirLight.shadow.camera.right = 60;
  dirLight.shadow.camera.top = 60;
  dirLight.shadow.camera.bottom = -20;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 150;
  scene.add(dirLight);

  fillLight = new THREE.DirectionalLight(0x8899bb, 0.4);
  fillLight.position.set(-30, 20, -15);
  scene.add(fillLight);
}

function setupDarkLighting() {
  if (ambientLight) { scene.remove(ambientLight); scene.remove(hemiLight); scene.remove(dirLight); scene.remove(fillLight); }

  ambientLight = new THREE.AmbientLight(0x404060, 0.6);
  scene.add(ambientLight);

  hemiLight = new THREE.HemisphereLight(0x6688cc, 0x443322, 0.5);
  scene.add(hemiLight);

  dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
  dirLight.position.set(30, 40, 20);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.left = -40;
  dirLight.shadow.camera.right = 40;
  dirLight.shadow.camera.top = 40;
  dirLight.shadow.camera.bottom = -10;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 100;
  scene.add(dirLight);

  fillLight = new THREE.DirectionalLight(0x8899bb, 0.3);
  fillLight.position.set(-20, 15, -10);
  scene.add(fillLight);
}

// ============================================================
// SKY + GROUND
// ============================================================
let skyMesh = null;
let groundPlane = null;
let gridHelper = null;

function createGrassTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext('2d');

  // Base green
  ctx.fillStyle = '#3a7a2a';
  ctx.fillRect(0, 0, 512, 512);

  // Add grass-like noise
  for (let i = 0; i < 30000; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const brightness = 0.7 + Math.random() * 0.6;
    const r = Math.floor(40 * brightness + Math.random() * 20);
    const g = Math.floor(100 * brightness + Math.random() * 40);
    const b = Math.floor(30 * brightness + Math.random() * 15);
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(x, y, 1 + Math.random() * 2, 1);
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(12, 12);
  return texture;
}

function createSkyGradient() {
  const canvas = document.createElement('canvas');
  canvas.width = 2;
  canvas.height = 512;
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createLinearGradient(0, 0, 0, 512);
  gradient.addColorStop(0, '#1a3a6a');    // deep blue at zenith
  gradient.addColorStop(0.3, '#4a7abb');  // medium blue
  gradient.addColorStop(0.6, '#7ab4dd');  // light blue
  gradient.addColorStop(0.85, '#b8daf0'); // pale blue near horizon
  gradient.addColorStop(1.0, '#d4e8f4');  // very pale at horizon
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 2, 512);
  return new THREE.CanvasTexture(canvas);
}

function setupEnvironment() {
  // Remove old sky/ground
  if (skyMesh) { scene.remove(skyMesh); skyMesh.geometry.dispose(); skyMesh.material.dispose(); skyMesh = null; }
  if (groundPlane) { scene.remove(groundPlane); groundPlane.geometry.dispose(); groundPlane.material.dispose(); groundPlane = null; }
  if (gridHelper) { scene.remove(gridHelper); gridHelper = null; }

  if (outdoorEnv) {
    // Sky sphere
    const skyGeo = new THREE.SphereGeometry(400, 32, 32);
    const skyTex = createSkyGradient();
    const skyMat = new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide, depthWrite: false });
    skyMesh = new THREE.Mesh(skyGeo, skyMat);
    scene.add(skyMesh);

    // Grass ground
    const grassTex = createGrassTexture();
    const gpGeo = new THREE.PlaneGeometry(300, 300);
    const gpMat = new THREE.MeshStandardMaterial({ map: grassTex, roughness: 0.9, metalness: 0.0 });
    groundPlane = new THREE.Mesh(gpGeo, gpMat);
    groundPlane.rotation.x = -Math.PI / 2;
    groundPlane.position.y = -0.01;
    groundPlane.receiveShadow = true;
    scene.add(groundPlane);

    scene.background = null;
    scene.fog = new THREE.FogExp2(0xb8daf0, 0.003);
    setupOutdoorLighting();
  } else {
    // Dark void
    scene.background = new THREE.Color(0x0a0a0f);
    scene.fog = new THREE.FogExp2(0x0a0a0f, 0.006);

    const gpGeo = new THREE.PlaneGeometry(80, 80);
    const gpMat = new THREE.MeshStandardMaterial({ color: 0x1a1a22, metalness: 0.0, roughness: 0.9 });
    groundPlane = new THREE.Mesh(gpGeo, gpMat);
    groundPlane.rotation.x = -Math.PI / 2;
    groundPlane.position.y = -0.01;
    groundPlane.receiveShadow = true;
    scene.add(groundPlane);

    setupDarkLighting();
  }

  // Grid
  const gridSize = outdoorEnv ? 120 : 80;
  gridHelper = new THREE.GridHelper(gridSize, gridSize,
    outdoorEnv ? 0x2a5a1a : 0x222233,
    outdoorEnv ? 0x327a22 : 0x151520
  );
  gridHelper.position.y = 0.01;
  gridHelper.material.transparent = true;
  gridHelper.material.opacity = outdoorEnv ? 0.15 : 0.5;
  gridHelper.visible = showGrid;
  scene.add(gridHelper);
}

// ============================================================
// MATERIALS
// ============================================================
const domeMaterial = new THREE.MeshPhysicalMaterial({
  color: 0x4466aa,
  transparent: true,
  opacity: 0.7,
  metalness: 0.1,
  roughness: 0.5,
  side: THREE.DoubleSide,
  depthWrite: false
});

const domeWireMaterial = new THREE.MeshBasicMaterial({
  color: 0x88aaff,
  wireframe: true,
  transparent: true,
  opacity: 0.15
});

const riserMaterial = new THREE.MeshPhysicalMaterial({
  color: 0x666677,
  metalness: 0.2,
  roughness: 0.6,
  side: THREE.DoubleSide
});

// Wing building materials
const wingWallMaterial = new THREE.MeshStandardMaterial({
  color: 0xd4c4a0,
  roughness: 0.7,
  metalness: 0.05,
  side: THREE.DoubleSide
});

const wingWallCollisionMaterial = new THREE.MeshStandardMaterial({
  color: 0xcc6644,
  roughness: 0.7,
  metalness: 0.05,
  side: THREE.DoubleSide
});

const wingRoofMaterial = new THREE.MeshStandardMaterial({
  color: 0x4a3a2a,
  roughness: 0.5,
  metalness: 0.1,
  side: THREE.DoubleSide
});

const wingRoofCollisionMaterial = new THREE.MeshStandardMaterial({
  color: 0x8a3030,
  roughness: 0.5,
  metalness: 0.1,
  side: THREE.DoubleSide
});

const wingFloorMaterial = new THREE.MeshStandardMaterial({
  color: 0x887766,
  roughness: 0.8,
  metalness: 0.0,
  side: THREE.DoubleSide
});

const postMaterial = new THREE.MeshStandardMaterial({
  color: 0x8b6914,
  roughness: 0.6,
  metalness: 0.1
});


const partitionWallMaterial = new THREE.MeshStandardMaterial({
  color: 0xccbbaa,
  roughness: 0.8,
  metalness: 0.0,
  side: THREE.DoubleSide,
  transparent: true,
  opacity: 0.85
});

// Handle materials for interactive editing
const handleMaterial = new THREE.MeshBasicMaterial({
  color: 0xffcc00, transparent: true, opacity: 0.7, depthTest: false
});
const handleHoverMaterial = new THREE.MeshBasicMaterial({
  color: 0xffffff, transparent: true, opacity: 0.9, depthTest: false
});
const handleDragMaterial = new THREE.MeshBasicMaterial({
  color: 0xffee44, transparent: true, opacity: 1.0, depthTest: false
});
const wallEndpointMaterial = new THREE.MeshBasicMaterial({
  color: 0x66aaff, transparent: true, opacity: 0.8, depthTest: false
});

const markerMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
const ringFitMaterial = new THREE.LineBasicMaterial({ color: 0xffaa22, linewidth: 2 });
const ringCollisionMaterial = new THREE.LineBasicMaterial({ color: 0xff4422, linewidth: 2 });

// ============================================================
// SCENE OBJECT CONTAINERS
// ============================================================
let domeGroup = new THREE.Group();
scene.add(domeGroup);

let wingGroupL = null;
let wingGroupR = null;
let markerGroup = new THREE.Group();
scene.add(markerGroup);
let widthRingLine = null;
let collisionRingLine = null;

let interiorGroup = new THREE.Group();
interiorGroup.visible = false;
scene.add(interiorGroup);

let canopyWrapL = null, canopyWrapR = null;
let entryBoxGroup = null;

let postGroup = new THREE.Group();
scene.add(postGroup);

let dimensionGroup = new THREE.Group();
dimensionGroup.visible = false;
scene.add(dimensionGroup);

let handleGroup = new THREE.Group();
handleGroup.visible = false;
scene.add(handleGroup);

let customWallGroup = new THREE.Group();
scene.add(customWallGroup);

let octHandleGroup = new THREE.Group();
octHandleGroup.visible = false;
scene.add(octHandleGroup);

let wallEndpointGroup = new THREE.Group();
scene.add(wallEndpointGroup);

let wallTopHandleGroup = new THREE.Group();
scene.add(wallTopHandleGroup);

// ============================================================
// GEOMETRY: CREATE DOME SHELL
// ============================================================
function createDomeShell(cfg) {
  const R = cfg.sphereRadius;
  const h = cfg.shellHeight;
  const centerY = h - R;

  const latSegments = 48;
  const lonSegments = 64;

  const positions = [];
  const indices = [];
  const normals = [];

  for (let lat = 0; lat <= latSegments; lat++) {
    const t = lat / latSegments;
    const y = t * h;
    const dy = y - centerY;
    const rSq = R * R - dy * dy;
    const rSphere = rSq > 0 ? Math.sqrt(rSq) : 0;

    for (let lon = 0; lon <= lonSegments; lon++) {
      const phi = (lon / lonSegments) * Math.PI * 2;
      // Clip to octagonal boundary if enabled
      let r = rSphere;
      if (octagonalBase) {
        const rOct = octRadiusAtAngle(phi, cfg.baseRadius);
        r = Math.min(rSphere, rOct);
      }
      const x = r * Math.cos(phi);
      const z = r * Math.sin(phi);
      positions.push(x, y, z);

      const nx = x;
      const ny = y - centerY;
      const nz = z;
      const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
      normals.push(nx/len, ny/len, nz/len);
    }
  }

  for (let lat = 0; lat < latSegments; lat++) {
    for (let lon = 0; lon < lonSegments; lon++) {
      const a = lat * (lonSegments + 1) + lon;
      const b = a + lonSegments + 1;
      indices.push(a, b, a + 1);
      indices.push(a + 1, b, b + 1);
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
  geometry.setIndex(indices);
  return geometry;
}

// ============================================================
// GEOMETRY: CREATE GEODESIC WIREFRAME
// ============================================================
function createGeodesicWireframe(cfg) {
  const R = cfg.sphereRadius;
  const h = cfg.shellHeight;
  const centerY = h - R;
  const yMin = R - h;

  const icoGeo = new THREE.IcosahedronGeometry(R, 3);
  const posArr = icoGeo.getAttribute('position').array;
  const indexArr = icoGeo.index ? icoGeo.index.array : null;
  const edgeSet = new Set();

  function vtxY(i) { return posArr[i * 3 + 1]; }
  function addEdge(a, b) { edgeSet.add(Math.min(a,b) + ',' + Math.max(a,b)); }

  if (indexArr) {
    for (let i = 0; i < indexArr.length; i += 3) {
      const a = indexArr[i], b = indexArr[i+1], c = indexArr[i+2];
      const above = (vtxY(a) >= yMin ? 1 : 0) + (vtxY(b) >= yMin ? 1 : 0) + (vtxY(c) >= yMin ? 1 : 0);
      if (above >= 2) { addEdge(a, b); addEdge(b, c); addEdge(c, a); }
    }
  }

  const linePositions = [];
  const offY = -R + h;
  for (const key of edgeSet) {
    const [ai, bi] = key.split(',').map(Number);
    const ax = posArr[ai*3], ay = Math.max(posArr[ai*3+1], yMin), az = posArr[ai*3+2];
    const bx = posArr[bi*3], by = Math.max(posArr[bi*3+1], yMin), bz = posArr[bi*3+2];
    linePositions.push(ax, ay + offY, az, bx, by + offY, bz);
  }

  const lineGeo = new THREE.BufferGeometry();
  lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
  icoGeo.dispose();
  return lineGeo;
}

// ============================================================
// COMPUTE DOME WIDTH AT HEIGHT
// ============================================================
function domeWidthAtHeight(cfg, heightFromGround, riserFt) {
  if (heightFromGround <= riserFt) return cfg.diameter;
  if (heightFromGround > riserFt + cfg.shellHeight) return 0;
  const y = heightFromGround - riserFt;
  const R = cfg.sphereRadius;
  const h = cfg.shellHeight;
  const val = R * R - (R - h + y) * (R - h + y);
  if (val <= 0) return 0;
  return 2 * Math.sqrt(val);
}

// ============================================================
// DOME Z AT LOCAL (wing-local dome surface z-coordinate)
// ============================================================
// Returns the dome surface z in wing-local coords for a point (x, y).
// cfg: dome config, D: chord midpoint distance sqrt(R²-hw²), riserFt: riser height in ft.
// In the riser zone the dome boundary is a vertical cylinder so z_dome = sqrt(baseR²-x²)-D.
// In the shell zone the sphere radius shrinks with height.
function domeZAtLocal(x, y, cfg, D, riserFt) {
  const baseR = cfg.baseRadius;
  const R = cfg.sphereRadius;
  const h = cfg.shellHeight;
  const centerY = h - R; // sphere center in dome-local y (relative to riser top)

  if (y >= riserFt + h) return 0; // above dome

  let rAtY; // horizontal dome radius at height y
  if (y <= riserFt) {
    // Riser zone: vertical cylinder at baseRadius
    rAtY = baseR;
  } else {
    // Shell zone: sphere surface
    const yShell = y - riserFt; // height above riser top
    const dy = yShell - centerY; // distance from sphere center (dome-local)
    const rSq = R * R - dy * dy;
    if (rSq <= 0) return 0;
    rAtY = Math.sqrt(rSq);
  }

  const valSq = rAtY * rAtY - x * x;
  if (valSq <= 0) return 0; // dome doesn't reach this x at this height
  return Math.sqrt(valSq) - D;
}

// ============================================================
// DOME RADIUS AT Y — horizontal radius of dome at a given height
// ============================================================
function domeRadiusAtY(y, cfg, riserFt) {
  if (y <= riserFt) return cfg.baseRadius;
  const yShell = y - riserFt;
  if (yShell >= cfg.shellHeight) return 0;
  const centerY = cfg.shellHeight - cfg.sphereRadius;
  const dy = yShell - centerY;
  const rSq = cfg.sphereRadius * cfg.sphereRadius - dy * dy;
  return rSq > 0 ? Math.sqrt(rSq) : 0;
}

// ============================================================
// COMPUTE MINIMUM RISER
// ============================================================
function minRiserInches(cfg, targetHeightFt, targetWidthFt) {
  const R = cfg.sphereRadius;
  const h = cfg.shellHeight;
  const halfW = targetWidthFt / 2;
  if (halfW >= R) return Infinity;
  const riserFt = R - h + targetHeightFt - Math.sqrt(R * R - halfW * halfW);
  return Math.max(0, riserFt * 12);
}

// ============================================================
// FORMAT HELPERS
// ============================================================
function fmtFtIn(ft) {
  const totalIn = Math.round(ft * 12);
  const f = Math.floor(totalIn / 12);
  const i = totalIn % 12;
  return `${f}'-${i}"`;
}

function fmtInches(inches) {
  return `${Math.abs(inches).toFixed(1)}"`;
}

// ============================================================
// BUILD WING STRUCTURE (3D lean-to building)
// ============================================================
function buildWingStructure(cfg, riserFt, fits, heights, innerSide, arcInfo) {
  const group = new THREE.Group();

  // Four independent corner heights (passed in so wings can be mirrored)
  const hNL = heights.hNL;  // near-left (dome, x=-hw)
  const hNR = heights.hNR;  // near-right (dome, x=+hw)
  const hFL = heights.hFL;  // far-left
  const hFR = heights.hFR;  // far-right
  const width = wingWidthFt;
  const depth = wingDepthFt;
  const hw = width / 2;
  const R = cfg.baseRadius;
  const D = Math.sqrt(R * R - hw * hw);

  const wallMat = fits ? wingWallMaterial : wingWallCollisionMaterial;
  const roofMat = fits ? wingRoofMaterial : wingRoofCollisionMaterial;

  // Roof overhang: extends past wall edges, especially on lower side(s)
  const ovh = roofOverhangFt;
  const minOvh = 0.3; // minimum structural overhang on all sides

  // --- Far wall (trapezoid: hFL on left, hFR on right) ---
  {
    const v0 = [-hw, 0, depth];
    const v1 = [-hw, hFL, depth];
    const v2 = [hw, hFR, depth];
    const v3 = [hw, 0, depth];
    const verts = new Float32Array([
      ...v0, ...v1, ...v2,
      ...v0, ...v2, ...v3
    ]);
    const normals = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1]);
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
    geo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    const mesh = new THREE.Mesh(geo, wallMat);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    group.add(mesh);
    // Far wall vertex labels
    addVertexLabel(group, 'fw.lb', -hw, 0, depth);
    addVertexLabel(group, 'fw.lt', -hw, hFL, depth);
    addVertexLabel(group, 'fw.rt', hw, hFR, depth);
    addVertexLabel(group, 'fw.rb', hw, 0, depth);
  }

  // --- Side walls ---
  // Inner wall (facing dome center/entry): follows world-space arc if arcInfo provided
  // Outer wall (facing away from dome): straight near edge (flat plane)
  const nWallSegs = 12;
  for (const [side, nearH, farH] of [[-1, hNL, hFL], [1, hNR, hFR]]) {
    const xBase = side * hw;
    const isInner = (side === innerSide);
    const wallPositions = [];
    const wallIndices = [];

    // Top z at dome surface (used by both wall types)
    const zNearTop = domeZAtLocal(xBase, nearH, cfg, D, riserFt);

    // Inner wall with world-space arc: subdivide along depth
    // arcInfo has { cx, cz, R } — arc circle center in wing-local coords
    const useArc = isInner && arcInfo != null;
    const nDepthSegs = useArc ? 16 : 1;

    // Roof z-range for this wall's x column (used to clamp wall height)
    const ovhFarWall = minOvh + ovh * 0.5;
    const roofZInner = zNearTop - minOvh;
    const roofZOuter = depth + ovhFarWall;
    const roofZRange = roofZOuter - roofZInner;

    for (let i = 0; i <= nWallSegs; i++) {
      const tH = i / nWallSegs;
      const yNear = tH * nearH;
      const yFar = tH * farH;

      // Near-edge z: dome curvature (both walls follow dome surface)
      const zNear = domeZAtLocal(xBase, yNear, cfg, D, riserFt);
      const zFar = depth;
      const chordLen = zFar - zNear;

      for (let j = 0; j <= nDepthSegs; j++) {
        const tD = j / nDepthSegs;

        // Interpolate y and z from near to far edge
        let y = yNear + tD * (yFar - yNear);
        const z = zNear + tD * chordLen;

        // Clamp wall height to roof height at this z (prevents wall
        // clipping through roof near dome where z parameterizations differ)
        const roofTD = Math.max(0, Math.min(1, (z - roofZInner) / roofZRange));
        const roofY = nearH + roofTD * (farH - nearH);
        y = Math.min(y, roofY);

        // X: flat for outer wall, arc for inner wall
        let xPos = xBase;
        if (useArc) {
          // World-space arc circle in wing-local coords: (x-cx)²+(z-cz)²=R²
          // x = cx - sign * sqrt(R² - (z-cz)²)
          // Negate innerSide so wall bows inward (concave, toward dome center)
          const dzArc = z - arcInfo.cz;
          const valSq = arcInfo.R * arcInfo.R - dzArc * dzArc;
          if (valSq > 0) {
            xPos = arcInfo.cx - innerSide * Math.sqrt(valSq);
          }
          // Re-clamp wall height to roof at actual xPos (arc shifts x,
          // so roof height at xPos differs from height at xBase)
          const arcLt = Math.max(0, Math.min(1, (xPos + hw) / width));
          const arcNearH = hNL + (hNR - hNL) * arcLt;
          const arcFarH = hFL + (hFR - hFL) * arcLt;
          const arcRoofY = arcNearH + roofTD * (arcFarH - arcNearH);
          y = Math.min(y, arcRoofY);
        }

        wallPositions.push(xPos, y, z);
      }
    }

    // Build triangle indices for the grid
    const cols = nDepthSegs + 1;
    for (let i = 0; i < nWallSegs; i++) {
      for (let j = 0; j < nDepthSegs; j++) {
        const a = i * cols + j;
        const b = i * cols + j + 1;
        const c = (i + 1) * cols + j;
        const d = (i + 1) * cols + j + 1;
        if (side > 0) {
          wallIndices.push(a, b, c);
          wallIndices.push(c, b, d);
        } else {
          wallIndices.push(a, c, b);
          wallIndices.push(b, c, d);
        }
      }
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(wallPositions), 3));
    geo.setIndex(wallIndices);
    geo.computeVertexNormals();
    const mesh = new THREE.Mesh(geo, wallMat);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    group.add(mesh);

    // Side wall vertex labels at 4 corners
    const wt = isInner ? 'iw' : 'ow';
    const nb = 0;  // near-bottom (i=0, j=0)
    const nds = nDepthSegs * 3;  // far-bottom (i=0, j=last)
    const nt = nWallSegs * cols * 3;  // near-top (i=last, j=0)
    const ft = (nWallSegs * cols + nDepthSegs) * 3;  // far-top (i=last, j=last)
    addVertexLabel(group, wt+'.nb', wallPositions[nb], wallPositions[nb+1], wallPositions[nb+2]);
    addVertexLabel(group, wt+'.nt', wallPositions[nt], wallPositions[nt+1], wallPositions[nt+2]);
    addVertexLabel(group, wt+'.fb', wallPositions[nds], wallPositions[nds+1], wallPositions[nds+2]);
    addVertexLabel(group, wt+'.ft', wallPositions[ft], wallPositions[ft+1], wallPositions[ft+2]);
  }

  // --- Roof with overhang ---
  // Roof extends past walls. On the lower side(s), it overhangs by ovh.
  // On equal-height sides, overhang is symmetric.
  const leftH = (hNL + hFL) / 2;
  const rightH = (hNR + hFR) / 2;
  const leftIsLower = leftH <= rightH;
  const rightIsLower = rightH <= leftH;
  const ovhLeft = leftIsLower ? ovh : minOvh;
  const ovhRight = rightIsLower ? ovh : minOvh;
  const ovhFar = minOvh + ovh * 0.5;  // moderate far overhang

  const nRoofSegs = 16;
  const nRoofZSegs = (arcInfo != null) ? 16 : 1;  // Z subdivision when arc active
  const roofPositions = [];
  const roofIndices = [];

  for (let i = 0; i <= nRoofSegs; i++) {
    const t = i / nRoofSegs;
    const xStraight = (-hw - ovhLeft) + t * (width + ovhLeft + ovhRight);
    const xc = Math.max(-hw, Math.min(hw, xStraight));
    // Unclamped lerp so overhang continues the roof slope
    const lt = (xStraight + hw) / width;
    const nearHAtX = hNL + (hNR - hNL) * lt;
    const farHAtX = hFL + (hFR - hFL) * lt;
    // Use clamped height for dome-Z calculation (can't query dome beyond wing width)
    const ltClamped = Math.max(0, Math.min(1, lt));
    const nearHClamped = hNL + (hNR - hNL) * ltClamped;
    const zInner = domeZAtLocal(xc, nearHClamped, cfg, D, riserFt) - minOvh;
    const zOuter = depth + ovhFar;

    for (let j = 0; j <= nRoofZSegs; j++) {
      const tD = j / nRoofZSegs;
      const z = zInner + tD * (zOuter - zInner);
      const y = nearHAtX + tD * (farHAtX - nearHAtX);

      // Shift inner-side X to follow arc curve at this depth
      let x = xStraight;
      if (arcInfo != null) {
        const dzArc = z - arcInfo.cz;
        const valSq = arcInfo.R * arcInfo.R - dzArc * dzArc;
        if (valSq > 0) {
          const arcWallX = arcInfo.cx - innerSide * Math.sqrt(valSq);
          const arcShift = arcWallX - innerSide * hw;
          // Blend: 0 at outer wall / center, 1 at inner wall and overhang
          const blend = Math.max(0, Math.min(1, xStraight * innerSide / hw));
          x = xStraight + arcShift * blend;
        }
      }

      roofPositions.push(x, y, z);
    }
  }
  for (let i = 0; i < nRoofSegs; i++) {
    for (let j = 0; j < nRoofZSegs; j++) {
      const a = i * (nRoofZSegs + 1) + j;
      const b = a + 1;
      const c = (i + 1) * (nRoofZSegs + 1) + j;
      const d = c + 1;
      roofIndices.push(a, c, b);
      roofIndices.push(b, c, d);
    }
  }

  const roofGeo = new THREE.BufferGeometry();
  roofGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(roofPositions), 3));
  roofGeo.setIndex(roofIndices);
  roofGeo.computeVertexNormals();
  const roof = new THREE.Mesh(roofGeo, roofMat);
  roof.castShadow = true;
  roof.receiveShadow = true;
  group.add(roof);

  // Roof vertex labels at corners and key edges
  {
    const rCols = nRoofZSegs + 1;
    const rRows = nRoofSegs + 1;
    // Helper to get roof vertex position
    const rv = (i, j) => {
      const idx = (i * rCols + j) * 3;
      return [roofPositions[idx], roofPositions[idx+1], roofPositions[idx+2]];
    };
    // 4 corners
    const [x0,y0,z0] = rv(0, 0);                     addVertexLabel(group, 'rf.ln', x0, y0, z0);
    const [x1,y1,z1] = rv(0, nRoofZSegs);            addVertexLabel(group, 'rf.lf', x1, y1, z1);
    const [x2,y2,z2] = rv(nRoofSegs, 0);             addVertexLabel(group, 'rf.rn', x2, y2, z2);
    const [x3,y3,z3] = rv(nRoofSegs, nRoofZSegs);    addVertexLabel(group, 'rf.rf', x3, y3, z3);
    // Wall-edge corners (where overhang meets wall)
    // Left wall edge: i where x ≈ -hw (ovhLeft segs in from left)
    const iLeftWall = Math.round(ovhLeft / (width + ovhLeft + ovhRight) * nRoofSegs);
    const iRightWall = Math.round((ovhLeft + width) / (width + ovhLeft + ovhRight) * nRoofSegs);
    if (iLeftWall > 0 && iLeftWall < nRoofSegs) {
      const [a,b,c] = rv(iLeftWall, 0);              addVertexLabel(group, 'rf.lwn', a, b, c);
      const [d,e,f] = rv(iLeftWall, nRoofZSegs);     addVertexLabel(group, 'rf.lwf', d, e, f);
    }
    if (iRightWall > 0 && iRightWall < nRoofSegs) {
      const [a,b,c] = rv(iRightWall, 0);             addVertexLabel(group, 'rf.rwn', a, b, c);
      const [d,e,f] = rv(iRightWall, nRoofZSegs);    addVertexLabel(group, 'rf.rwf', d, e, f);
    }
  }

  // --- Floor (curved inner edge follows dome arc) ---
  const nFloorSegs = 16;
  const floorPositions = [];
  const floorIndices = [];
  for (let i = 0; i <= nFloorSegs; i++) {
    const x = -hw + (width * i) / nFloorSegs;
    const z = Math.sqrt(R * R - x * x) - D;
    floorPositions.push(x, 0.02, z);
  }
  for (let i = 0; i <= nFloorSegs; i++) {
    const x = -hw + (width * i) / nFloorSegs;
    floorPositions.push(x, 0.02, depth);
  }
  const nfv = nFloorSegs + 1;
  for (let i = 0; i < nFloorSegs; i++) {
    const il = i, ir = i + 1, ol = nfv + i, or2 = nfv + i + 1;
    floorIndices.push(il, ol, ir);
    floorIndices.push(ir, ol, or2);
  }
  const floorGeo = new THREE.BufferGeometry();
  floorGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(floorPositions), 3));
  floorGeo.setIndex(floorIndices);
  floorGeo.computeVertexNormals();
  const floor = new THREE.Mesh(floorGeo, wingFloorMaterial);
  floor.receiveShadow = true;
  group.add(floor);

  return group;
}

// ============================================================
// POSITION WINGS ON DOME
// ============================================================
function positionWingOnDome(wingGroup, cfg, angleFromFrontDeg, side) {
  // Wings connect to the dome at a point on its circumference.
  // The wing extends OUTWARD from the dome (local +Z points away from center).
  //
  // Coordinate system:
  //   +Z is front (entry side), dome centered at origin
  //   Wing's local +Z must point radially outward from the dome at its connection angle
  //
  // Three.js rotation.y of α transforms local -Z to (-sin(α), 0, -cos(α))
  // and local +Z to (-sin(α), 0, cos(α))... no, let me be precise:
  //
  // Rotation matrix around Y by α:
  //   x' = x*cos(α) + z*sin(α)
  //   z' = -x*sin(α) + z*cos(α)
  //
  // Local +Z (0,0,1) transforms to: (sin(α), 0, cos(α))
  //
  // The outward radial direction at angle θ from +Z is: (sin(θ), 0, cos(θ))
  //
  // So we need rotation.y = θ to make local +Z point outward. ✓

  const angleRad = (angleFromFrontDeg * Math.PI) / 180;
  const r = cfg.baseRadius;
  const hw = wingWidthFt / 2;

  // Place wing so side-wall corners (±hw from center) sit ON the dome circle.
  // D = sqrt(R² - hw²) is the chord midpoint distance from dome center.
  const D = Math.sqrt(r * r - hw * hw);

  // Wing splay angle (from radial outward direction)
  const wingAngleRad = (wingAngleDeg * Math.PI) / 180;

  // Final orientation = placement angle + splay. Position must use the final
  // angle so the perpendicular from dome center to the chord (inner edge)
  // passes through the chord midpoint — ensuring both corners sit ON the dome circle.
  const finalAngle = angleRad + (side === 'left' ? wingAngleRad : -wingAngleRad);
  const cx = D * Math.sin(finalAngle);
  const cz = D * Math.cos(finalAngle);

  wingGroup.position.set(cx, 0, cz);
  wingGroup.rotation.y = finalAngle;
}

// ============================================================
// BUILD CORNER POSTS
// ============================================================
function buildCornerPosts(cfg) {
  // Clear old posts
  while (postGroup.children.length > 0) {
    const c = postGroup.children[0];
    postGroup.remove(c);
    if (c.geometry) c.geometry.dispose();
  }

  if (!showWings) return;

  const postSize = 0.5; // 6" square posts
  const hw = wingWidthFt / 2;
  const d = wingDepthFt;

  for (const [wg, hFL_w, hFR_w] of [
    [wingGroupL, wingHFL, wingHFR],
    [wingGroupR, wingHFR, wingHFL]  // right wing has swapped L/R
  ]) {
    if (!wg) continue;
    // Far corners in wing local space (+Z is outward from dome)
    const wingLabel = wg === wingGroupL ? 'L' : 'R';
    let cpIdx = 0;
    for (const [lx, cornerH] of [[-hw, hFL_w], [hw, hFR_w]]) {
      const postH = Math.max(1, cornerH - 0.15);
      const postGeo = new THREE.BoxGeometry(postSize, postH, postSize);
      const wc = new THREE.Vector3(lx, 0, d).applyMatrix4(wg.matrixWorld);
      const post = new THREE.Mesh(postGeo, postMaterial);
      post.position.set(wc.x, postH / 2, wc.z);
      post.castShadow = true;
      postGroup.add(post);
      // Corner post labels
      const cpName = wingLabel + '.cp' + (cpIdx === 0 ? 'l' : 'r');
      addVertexLabel(postGroup, cpName+'.t', wc.x, postH, wc.z);
      addVertexLabel(postGroup, cpName+'.b', wc.x, 0, wc.z);
      cpIdx++;
    }
  }
}

// ============================================================
// BUILD CANOPY WRAP — continuous roof wrapping from wing around dome
// ============================================================
// side: +1 for left wing canopy, -1 for right wing canopy
function buildCanopyWrap(cfg, riserFt, side) {
  const group = new THREE.Group();
  if (!showWings) return group;

  const r = cfg.baseRadius;
  const hw = wingWidthFt / 2;
  const Dw = Math.sqrt(r * r - hw * hw);
  const wingAngleRad = (wingAngleDeg * Math.PI) / 180;

  // Recompute placement geometry (same as rebuildWings)
  const entryOuterX = entryWidth / 2 + 0.5;
  const storeAngle = Math.asin(Math.min(1, entryOuterX / r));
  const cornerOffset = Math.atan2(hw, Dw);
  const placementRad = storeAngle + cornerOffset;

  let finalAngle, innerSide;
  if (side > 0) {
    finalAngle = -placementRad + wingAngleRad;
    innerSide = finalAngle > 0 ? -1 : 1;
  } else {
    finalAngle = placementRad - wingAngleRad;
    innerSide = finalAngle > 0 ? -1 : 1;
  }

  // Inner near-corner height (entry-facing side of each wing at dome junction)
  let canopyH;
  if (side > 0) {
    canopyH = innerSide === -1 ? wingHNL : wingHNR;
  } else {
    canopyH = innerSide === +1 ? wingHNL : wingHNR;
  }

  // Dome radius at canopy height
  const rAtH = domeRadiusAtY(canopyH, cfg, riserFt);
  if (rAtH < 1) return group; // canopy height above dome — skip

  // World position of wing's inner near-corner (on dome circle)
  const cosF = Math.cos(finalAngle), sinF = Math.sin(finalAngle);
  const cornerWX = Dw * sinF + innerSide * hw * cosF;
  const cornerWZ = Dw * cosF - innerSide * hw * sinF;

  // Angular position of inner near-corner on dome circle
  const thetaStart = Math.atan2(cornerWX, cornerWZ);

  // Entry gap: stop angle where gap between canopy tips = entryWidth
  const thetaStop = Math.asin(Math.min(0.95, entryWidth / (2 * rAtH)));
  const thetaEnd = side > 0 ? thetaStop : -thetaStop;

  // Skip if canopy would be negligible
  if (Math.abs(thetaStart - thetaEnd) < 0.02) return group;

  // Build parametric mesh: U = angular sweep, V = radial (inner to outer)
  const nAngSegs = 16;
  const nRadSegs = 4;
  const positions = [];
  const indices = [];

  const rInner = rAtH + 0.3;  // small gap from dome surface
  const rOuter = rAtH + canopyDepthFt;

  for (let i = 0; i <= nAngSegs; i++) {
    const t = i / nAngSegs;
    const theta = thetaStart + t * (thetaEnd - thetaStart);

    // Height: match wing and entry box height across entire sweep
    const h = canopyH;

    for (let j = 0; j <= nRadSegs; j++) {
      const tR = j / nRadSegs;
      const rr = rInner + tR * (rOuter - rInner);
      const x = rr * Math.sin(theta);
      const z = rr * Math.cos(theta);
      positions.push(x, h, z);
    }
  }

  // Triangle indices — winding for upward normals
  const cols = nRadSegs + 1;
  for (let i = 0; i < nAngSegs; i++) {
    for (let j = 0; j < nRadSegs; j++) {
      const a = i * cols + j;
      const b = a + 1;
      const c = (i + 1) * cols + j;
      const d = c + 1;
      if (side > 0) {
        indices.push(a, c, b);
        indices.push(b, c, d);
      } else {
        indices.push(a, b, c);
        indices.push(c, b, d);
      }
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
  geo.setIndex(indices);
  geo.computeVertexNormals();
  const mesh = new THREE.Mesh(geo, wingRoofMaterial);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  group.add(mesh);

  // Canopy vertex labels at 4 corners
  const sideLabel = side > 0 ? 'L' : 'R';
  {
    const cv = (i, j) => {
      const idx = (i * (nRadSegs + 1) + j) * 3;
      return [positions[idx], positions[idx+1], positions[idx+2]];
    };
    // Start (wing end): inner and outer
    const [a,b,c] = cv(0, 0);               addVertexLabel(group, sideLabel+'.cn.wi', a, b, c);
    const [d,e,f] = cv(0, nRadSegs);        addVertexLabel(group, sideLabel+'.cn.wo', d, e, f);
    // End (entry end): inner and outer
    const [g,h2,k] = cv(nAngSegs, 0);       addVertexLabel(group, sideLabel+'.cn.ei', g, h2, k);
    const [l,m,n] = cv(nAngSegs, nRadSegs); addVertexLabel(group, sideLabel+'.cn.eo', l, m, n);
  }

  // Support posts along outer edge (25%, 50%, 75% of angular sweep)
  const postSize = 0.4;
  let postIdx = 1;
  for (const tPost of [0.25, 0.5, 0.75]) {
    const theta = thetaStart + tPost * (thetaEnd - thetaStart);
    const h = canopyH;
    const x = rOuter * Math.sin(theta);
    const z = rOuter * Math.cos(theta);
    const postGeo = new THREE.BoxGeometry(postSize, h, postSize);
    const post = new THREE.Mesh(postGeo, postMaterial);
    post.position.set(x, h / 2, z);
    post.castShadow = true;
    group.add(post);
    // Post labels — top and bottom
    addVertexLabel(group, sideLabel+'.p'+postIdx+'.t', x, h, z);
    addVertexLabel(group, sideLabel+'.p'+postIdx+'.b', x, 0, z);
    postIdx++;
  }

  return group;
}

// Shared geometry/material for vertex dot markers
const _vtxDotGeo = new THREE.SphereGeometry(0.03, 6, 4);
const _vtxDotMat = new THREE.MeshBasicMaterial({ color: 0xff3300, depthTest: false });
_vtxDotMat.transparent = true;
_vtxDotMat.opacity = 0.9;

// Position registry to deconflict overlapping labels (cleared each rebuild)
let _vtxLabelPositions = [];
const _vtxLabelSpacing = 0.22;  // vertical spacing between stacked labels
const _vtxLabelThreshold = 0.3; // distance below which labels count as overlapping

// Small vertex label sprite for debugging geometry
function addVertexLabel(group, text, x, y, z) {
  if (!showVertexLabels) return;

  // Bright dot at exact vertex position
  const dot = new THREE.Mesh(_vtxDotGeo, _vtxDotMat);
  dot.position.set(x, y, z);
  dot.renderOrder = 999;
  group.add(dot);

  // Count how many existing labels are near this position and offset accordingly
  let stackCount = 0;
  for (var i = 0; i < _vtxLabelPositions.length; i++) {
    var p = _vtxLabelPositions[i];
    var dx = p[0] - x, dy = p[1] - y, dz = p[2] - z;
    if (Math.sqrt(dx*dx + dy*dy + dz*dz) < _vtxLabelThreshold) {
      stackCount++;
    }
  }
  _vtxLabelPositions.push([x, y, z]);

  // Compact text label offset above the dot, stacked if overlapping
  var labelY = y + 0.35 + stackCount * _vtxLabelSpacing;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const dpr = 2;
  const fontSize = 9;
  const w = 80, h = 20;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  ctx.scale(dpr, dpr);
  ctx.font = 'bold ' + fontSize + 'px monospace';
  const mw = ctx.measureText(text).width;
  const pad = 2;
  const bx = (w - mw) / 2 - pad, by = (h - fontSize) / 2 - pad;
  const bw = mw + pad * 2, bh = fontSize + pad * 2;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(bx, by, bw, bh);
  ctx.fillStyle = '#ffee00';
  ctx.font = 'bold ' + fontSize + 'px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, w / 2, h / 2);
  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.position.set(x, labelY, z);
  sprite.scale.set(0.7, 0.18, 1);
  sprite.renderOrder = 999;
  group.add(sprite);
}

// ============================================================
// BUILD ENTRY BOX — rectangular vestibule between canopy tips
// ============================================================
function buildEntryBox(cfg, riserFt) {
  const group = new THREE.Group();

  // Determine canopy height (inner near-corner height, same logic as buildCanopyWrap)
  const r = cfg.baseRadius;
  const hw = wingWidthFt / 2;
  const Dw = Math.sqrt(r * r - hw * hw);
  const wingAngleRad = (wingAngleDeg * Math.PI) / 180;
  const eOuterX = entryWidth / 2 + 0.5;
  const storeAngle = Math.asin(Math.min(1, eOuterX / r));
  const cornerOffset = Math.atan2(hw, Dw);
  const placementRad = storeAngle + cornerOffset;
  const finalAngleL = -placementRad + wingAngleRad;
  const innerSideL = finalAngleL > 0 ? -1 : 1;
  const canopyH = innerSideL === -1 ? wingHNL : wingHNR;

  // Dome radius at canopy height
  const rAtH = domeRadiusAtY(canopyH, cfg, riserFt);
  if (rAtH < 1) return group;

  // Entry box dimensions
  const halfW = entryWidth / 2;
  const zBack = Math.sqrt(Math.max(0, rAtH * rAtH - halfW * halfW));
  const zFront = zBack + entryDepth;
  const roofH = canopyH;

  // Door dimensions
  const doorW = 3;
  const doorH = 7;
  const doorHalfW = doorW / 2;

  // Collision check for material selection
  const wingMaxHeight = Math.max(wingHNL, wingHNR, wingHFL, wingHFR);
  const widthAtWingTop = domeWidthAtHeight(cfg, wingMaxHeight, riserFt);
  const fits = widthAtWingTop >= wingWidthFt;
  const wallMat = fits ? wingWallMaterial : wingWallCollisionMaterial;
  const roofMat = fits ? wingRoofMaterial : wingRoofCollisionMaterial;

  // --- Side walls (skipped when connecting walls replace them) ---
  if (!connectWingsToEntry) {
    // Left side wall (X = -halfW, from zBack to zFront, ground to roofH)
    const sideGeoL = new THREE.PlaneGeometry(entryDepth, roofH);
    const sideL = new THREE.Mesh(sideGeoL, wallMat);
    sideL.position.set(-halfW, roofH / 2, (zBack + zFront) / 2);
    sideL.rotation.y = Math.PI / 2;
    sideL.castShadow = true;
    sideL.receiveShadow = true;
    group.add(sideL);

    // Right side wall (X = +halfW)
    const sideGeoR = new THREE.PlaneGeometry(entryDepth, roofH);
    const sideR = new THREE.Mesh(sideGeoR, wallMat);
    sideR.position.set(halfW, roofH / 2, (zBack + zFront) / 2);
    sideR.rotation.y = -Math.PI / 2;
    sideR.castShadow = true;
    sideR.receiveShadow = true;
    group.add(sideR);
  }

  // --- Front wall with door cutout (Z = zFront) ---
  // Built as 3 sub-rectangles: left of door, above door, right of door
  const leftOfDoorW = halfW - doorHalfW;
  const rightOfDoorW = halfW - doorHalfW;
  const aboveDoorH = roofH - doorH;

  if (leftOfDoorW > 0.01) {
    const fGeoL = new THREE.PlaneGeometry(leftOfDoorW, roofH);
    const fMeshL = new THREE.Mesh(fGeoL, wallMat);
    fMeshL.position.set(-halfW + leftOfDoorW / 2, roofH / 2, zFront);
    fMeshL.castShadow = true;
    fMeshL.receiveShadow = true;
    group.add(fMeshL);
  }

  if (rightOfDoorW > 0.01) {
    const fGeoR = new THREE.PlaneGeometry(rightOfDoorW, roofH);
    const fMeshR = new THREE.Mesh(fGeoR, wallMat);
    fMeshR.position.set(halfW - rightOfDoorW / 2, roofH / 2, zFront);
    fMeshR.castShadow = true;
    fMeshR.receiveShadow = true;
    group.add(fMeshR);
  }

  const aboveDoorHWall = roofH - doorH;
  if (aboveDoorHWall > 0.01) {
    const fGeoA = new THREE.PlaneGeometry(doorW, aboveDoorHWall);
    const fMeshA = new THREE.Mesh(fGeoA, wallMat);
    fMeshA.position.set(0, doorH + aboveDoorHWall / 2, zFront);
    fMeshA.castShadow = true;
    fMeshA.receiveShadow = true;
    group.add(fMeshA);
  }

  // --- Wall vertex labels ---
  // Left side wall corners
  addVertexLabel(group, 'wl.bb', -halfW, 0, zBack);       // wall-left, back-bottom
  addVertexLabel(group, 'wl.bt', -halfW, roofH, zBack);   // wall-left, back-top
  addVertexLabel(group, 'wl.fb', -halfW, 0, zFront);      // wall-left, front-bottom
  addVertexLabel(group, 'wl.ft', -halfW, roofH, zFront);  // wall-left, front-top
  // Right side wall corners
  addVertexLabel(group, 'wr.bb', halfW, 0, zBack);
  addVertexLabel(group, 'wr.bt', halfW, roofH, zBack);
  addVertexLabel(group, 'wr.fb', halfW, 0, zFront);
  addVertexLabel(group, 'wr.ft', halfW, roofH, zFront);
  // Front wall corners
  addVertexLabel(group, 'wf.lb', -halfW, 0, zFront);      // front wall, left-bottom
  addVertexLabel(group, 'wf.lt', -halfW, roofH, zFront);  // front wall, left-top
  addVertexLabel(group, 'wf.rb', halfW, 0, zFront);       // front wall, right-bottom
  addVertexLabel(group, 'wf.rt', halfW, roofH, zFront);   // front wall, right-top
  // Door opening corners
  addVertexLabel(group, 'dr.lb', -doorHalfW, 0, zFront);
  addVertexLabel(group, 'dr.lt', -doorHalfW, doorH, zFront);
  addVertexLabel(group, 'dr.rb', doorHalfW, 0, zFront);
  addVertexLabel(group, 'dr.rt', doorHalfW, doorH, zFront);

  // --- Roof ---
  // Core roof covers wall area exactly; overhang extends as angled eaves
  // matching the wing roof's cross-slope angle
  const ovh = roofOverhangFt;
  const backOvh = 0.3;  // minimal overhang at dome side
  const wingSlope = (Math.max(wingHNL, wingHNR) - Math.min(wingHNL, wingHNR)) / wingWidthFt;
  const ovhDrop = ovh * wingSlope;  // overhang droop matching wing roof angle

  if (entryRoofStyle === 'flat') {
    // 2x4 grid: no side overhang, front overhang only
    const flatGeo = new THREE.BufferGeometry();
    const xs = [-halfW, halfW];
    const zs = [zBack - backOvh, zBack, zFront, zFront + ovh];
    const positions = [];
    for (let r = 0; r < 4; r++) {
      const isOvhZ = (r === 0 || r === 3);
      for (let c = 0; c < 2; c++) {
        const y = isOvhZ ? roofH - ovhDrop : roofH;
        positions.push(xs[c], y, zs[r]);
      }
    }
    const idx = [];
    for (let r = 0; r < 3; r++) {
      const a = r * 2, b = a + 1, d = a + 2, e = d + 1;
      idx.push(a, d, b, b, d, e);
    }
    flatGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    flatGeo.setIndex(idx);
    flatGeo.computeVertexNormals();
    const roof = new THREE.Mesh(flatGeo, roofMat);
    roof.castShadow = true;
    roof.receiveShadow = true;
    group.add(roof);
    // Vertex labels
    const rowNames = ['bo', 'b', 'f', 'fo'];
    const colNames = ['l', 'r'];
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 2; c++) {
        const vi = (r * 2 + c) * 3;
        addVertexLabel(group, rowNames[r] + '.' + colNames[c], positions[vi], positions[vi+1], positions[vi+2]);
      }
    }
  } else if (entryRoofStyle === 'sloped') {
    // Core slopes from roofH at back to roofH - 0.5 at front
    // No side overhang, front overhang only
    const slopeGeo = new THREE.BufferGeometry();
    const slopeDrop = 0.5;
    const xs = [-halfW, halfW];
    const zs = [zBack - backOvh, zBack, zFront, zFront + ovh];
    // Core heights at back and front
    const hBack = roofH;
    const positions = [];
    for (let r = 0; r < 4; r++) {
      // Interpolate/extrapolate slope along Z
      const tZ = (zs[r] - zBack) / entryDepth;  // 0 at back, 1 at front, >1 past front
      const baseH = hBack - slopeDrop * tZ;  // continues slope through overhang
      for (let c = 0; c < 2; c++) {
        positions.push(xs[c], baseH, zs[r]);
      }
    }
    const idx = [];
    for (let r = 0; r < 3; r++) {
      const a = r * 2, b = a + 1, d = a + 2, e = d + 1;
      idx.push(a, d, b, b, d, e);
    }
    slopeGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    slopeGeo.setIndex(idx);
    slopeGeo.computeVertexNormals();
    const roof = new THREE.Mesh(slopeGeo, roofMat);
    roof.castShadow = true;
    roof.receiveShadow = true;
    group.add(roof);
    // Vertex labels
    const rowNames = ['bo', 'b', 'f', 'fo'];
    const colNames = ['l', 'r'];
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 2; c++) {
        const vi = (r * 2 + c) * 3;
        addVertexLabel(group, rowNames[r] + '.' + colNames[c], positions[vi], positions[vi+1], positions[vi+2]);
      }
    }
  } else if (entryRoofStyle === 'gable') {
    // Peak at center rising 0.5' above roofH; no side overhang, front overhang only
    const gableGeo = new THREE.BufferGeometry();
    const peakH = roofH + 0.5;
    // 3 cols: wall-left, peak, wall-right
    // 4 rows: back-ovh, back, front, front+ovh
    const zs = [zBack - backOvh, zBack, zFront, zFront + ovh];
    const positions = [];
    for (let r = 0; r < 4; r++) {
      positions.push(-halfW, roofH, zs[r]);   // left wall edge
      positions.push(0,      peakH, zs[r]);   // peak
      positions.push(halfW,  roofH, zs[r]);   // right wall edge
    }
    const idx = [];
    const cols = 3;
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 2; c++) {
        const a = r * cols + c, b = a + 1, d = a + cols, e = d + 1;
        idx.push(a, d, b, b, d, e);
      }
    }
    gableGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    gableGeo.setIndex(idx);
    gableGeo.computeVertexNormals();
    const roof = new THREE.Mesh(gableGeo, roofMat);
    roof.castShadow = true;
    roof.receiveShadow = true;
    group.add(roof);
    // Vertex labels
    const rowNames = ['bo', 'b', 'f', 'fo'];
    const colNames = ['l', 'pk', 'r'];
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 3; c++) {
        const vi = (r * 3 + c) * 3;
        addVertexLabel(group, rowNames[r] + '.' + colNames[c], positions[vi], positions[vi+1], positions[vi+2]);
      }
    }
  }

  // --- Floor ---
  const floorGeo = new THREE.PlaneGeometry(entryWidth, entryDepth);
  const floor = new THREE.Mesh(floorGeo, wingFloorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.position.set(0, 0.02, (zBack + zFront) / 2);
  floor.receiveShadow = true;
  group.add(floor);

  // Apply cutaway clipping
  group.traverse(child => {
    if (child.isMesh && child.material) {
      child.material.clippingPlanes = cutawayMode ? [cutawayPlane] : [];
    }
  });

  return group;
}

// ============================================================
// INTERIOR ROOMS
// ============================================================
function buildInterior(cfg, riserFt) {
  while (interiorGroup.children.length > 0) {
    const c = interiorGroup.children[0];
    interiorGroup.remove(c);
    if (c.geometry) c.geometry.dispose();
    if (c.material && c.material.map) c.material.map.dispose();
    if (c.material && c.material.dispose) c.material.dispose();
  }

  if (!showInterior) { interiorGroup.visible = false; return; }
  interiorGroup.visible = true;

  // --- Dome main floor zone ---
  const domeFloorGeo = new THREE.CircleGeometry(cfg.baseRadius - 0.5, 64);
  const domeFloorMat = new THREE.MeshBasicMaterial({
    color: 0xeeddcc, transparent: true, opacity: 0.1, side: THREE.DoubleSide, depthWrite: false
  });
  const domeFloor = new THREE.Mesh(domeFloorGeo, domeFloorMat);
  domeFloor.rotation.x = -Math.PI / 2;
  domeFloor.position.y = 0.05;
  interiorGroup.add(domeFloor);

  // --- Wing floor zones ---
  // We'll add colored zones inside each wing group by creating floor planes
  // and transforming them to world space using the wing group transforms.
  const hw = wingWidthFt / 2;
  const d = wingDepthFt;

  // Helper: bilinear interpolation of wing roof height at wing-local (x, z)
  // Reuses hw and d already declared above in buildInterior()
  function roofHeightAt(x, z, hNL, hNR, hFL, hFR) {
    const w2 = hw * 2; // full width
    const lt = Math.max(0, Math.min(1, (x + hw) / w2));
    const zt = Math.max(0, Math.min(1, z / d));
    const nearH = hNL + (hNR - hNL) * lt;
    const farH  = hFL + (hFR - hFL) * lt;
    return nearH + (farH - nearH) * zt;
  }

}

function addRoomLabel(text, x, y, z) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 128;
  ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
  ctx.fillRect(0, 0, 256, 128);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 22px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const lines = text.split('\n');
  const lineH = 28;
  const startY = 64 - (lines.length - 1) * lineH / 2;
  lines.forEach((line, i) => {
    ctx.font = i === 0 ? 'bold 22px -apple-system, sans-serif' : '16px -apple-system, sans-serif';
    ctx.fillText(line, 128, startY + i * lineH);
  });

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.position.set(x, y, z);
  sprite.scale.set(5, 2.5, 1);
  interiorGroup.add(sprite);
}

// ============================================================
// DIMENSION ANNOTATIONS
// ============================================================
const dimLineMaterial = new THREE.LineBasicMaterial({ color: 0x88ddff, transparent: true, opacity: 0.6 });

function makeDimSprite(text) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 0, 256, 64);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 20px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, 128, 32);

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(4, 1, 1);
  return sprite;
}

function addDimLine(group, p1, p2, label, offset) {
  // offset: small vector to push line away from surface to avoid z-fight
  const off = offset || new THREE.Vector3(0, 0, 0);
  const a = p1.clone().add(off);
  const b = p2.clone().add(off);
  const mid = a.clone().add(b).multiplyScalar(0.5);

  // Main line
  const geo = new THREE.BufferGeometry().setFromPoints([a, b]);
  const line = new THREE.Line(geo, dimLineMaterial);
  group.add(line);

  // Tick marks at endpoints (small perpendicular lines)
  const dir = b.clone().sub(a).normalize();
  const tickLen = 0.4;
  // Choose a perpendicular: if line is mostly vertical use X, else use Y
  let perp;
  if (Math.abs(dir.y) > 0.7) {
    perp = new THREE.Vector3(tickLen, 0, 0);
  } else {
    perp = new THREE.Vector3(0, tickLen, 0);
  }
  for (const ep of [a, b]) {
    const t1 = ep.clone().add(perp);
    const t2 = ep.clone().sub(perp);
    const tGeo = new THREE.BufferGeometry().setFromPoints([t1, t2]);
    group.add(new THREE.Line(tGeo, dimLineMaterial));
  }

  // Label sprite at midpoint
  const sprite = makeDimSprite(label);
  sprite.position.copy(mid.clone().add(off.clone().multiplyScalar(0.5)));
  group.add(sprite);
}

function buildWingDimensions(cfg, riserFt) {
  // Clear old dimensions
  while (dimensionGroup.children.length > 0) {
    const c = dimensionGroup.children[0];
    dimensionGroup.remove(c);
    if (c.geometry) c.geometry.dispose();
    if (c.material) {
      if (c.material.map) c.material.map.dispose();
      if (c.material.dispose) c.material.dispose();
    }
  }

  if (!showDimensions || !showWings) { dimensionGroup.visible = false; return; }
  dimensionGroup.visible = true;

  const hw = wingWidthFt / 2;
  const depth = wingDepthFt;
  const R = cfg.baseRadius;
  const D = Math.sqrt(R * R - hw * hw);

  for (const [wg, side] of [[wingGroupL, 'left'], [wingGroupR, 'right']]) {
    if (!wg) continue;

    const toWorld = (lx, ly, lz) => new THREE.Vector3(lx, ly, lz).applyMatrix4(wg.matrixWorld);
    const sideOff = side === 'left' ? -0.8 : 0.8;

    // --- Corner heights (4 vertical lines) ---
    // Near-left
    const nlZ = domeZAtLocal(-hw, wingHNL, cfg, D, riserFt);
    addDimLine(dimensionGroup,
      toWorld(-hw - sideOff, 0, nlZ),
      toWorld(-hw - sideOff, wingHNL, nlZ),
      fmtFtIn(wingHNL),
      new THREE.Vector3(0, 0, 0)
    );
    // Near-right
    const nrZ = domeZAtLocal(hw, wingHNR, cfg, D, riserFt);
    addDimLine(dimensionGroup,
      toWorld(hw + sideOff, 0, nrZ),
      toWorld(hw + sideOff, wingHNR, nrZ),
      fmtFtIn(wingHNR),
      new THREE.Vector3(0, 0, 0)
    );
    // Far-left
    addDimLine(dimensionGroup,
      toWorld(-hw - sideOff, 0, depth),
      toWorld(-hw - sideOff, wingHFL, depth),
      fmtFtIn(wingHFL),
      new THREE.Vector3(0, 0, 0)
    );
    // Far-right
    addDimLine(dimensionGroup,
      toWorld(hw + sideOff, 0, depth),
      toWorld(hw + sideOff, wingHFR, depth),
      fmtFtIn(wingHFR),
      new THREE.Vector3(0, 0, 0)
    );

    // --- Wing depth (along each side wall) ---
    const depthY = 0.3;
    addDimLine(dimensionGroup,
      toWorld(-hw - sideOff, depthY, domeZAtLocal(-hw, 0, cfg, D, riserFt)),
      toWorld(-hw - sideOff, depthY, depth),
      fmtFtIn(depth),
      new THREE.Vector3(0, 0, 0)
    );

    // --- Wing width (across dome-side edge at ground) ---
    const widthZ = domeZAtLocal(0, 0, cfg, D, riserFt);
    addDimLine(dimensionGroup,
      toWorld(-hw, -0.5, widthZ),
      toWorld(hw, -0.5, widthZ),
      fmtFtIn(wingWidthFt),
      new THREE.Vector3(0, 0, 0)
    );

    // --- Far wall width ---
    addDimLine(dimensionGroup,
      toWorld(-hw, -0.5, depth + 0.5),
      toWorld(hw, -0.5, depth + 0.5),
      fmtFtIn(wingWidthFt),
      new THREE.Vector3(0, 0, 0)
    );

    // --- Dome contact arc length at roof level ---
    const nArcSegs = 32;
    const avgNearH = (wingHNL + wingHNR) / 2;
    let arcLen = 0;
    const arcPoints = [];
    for (let i = 0; i <= nArcSegs; i++) {
      const t = i / nArcSegs;
      const x = -hw + t * wingWidthFt;
      const lt = (x + hw) / wingWidthFt;
      const roofH = wingHNL + (wingHNR - wingHNL) * lt;
      const z = domeZAtLocal(x, roofH, cfg, D, riserFt);
      const wp = toWorld(x, roofH + 0.3, z);
      arcPoints.push(wp);
      if (i > 0) {
        arcLen += arcPoints[i].distanceTo(arcPoints[i - 1]);
      }
    }
    // Draw the arc line
    if (arcPoints.length > 1) {
      const arcGeo = new THREE.BufferGeometry().setFromPoints(arcPoints);
      const arcLine = new THREE.Line(arcGeo, dimLineMaterial);
      dimensionGroup.add(arcLine);
      // Label at midpoint
      const midIdx = Math.floor(arcPoints.length / 2);
      const arcLabel = makeDimSprite('Arc: ' + fmtFtIn(arcLen));
      arcLabel.position.copy(arcPoints[midIdx].clone().add(new THREE.Vector3(0, 1.5, 0)));
      dimensionGroup.add(arcLabel);
    }

    // --- Side wall curve length (sum of near-edge segment distances) ---
    for (const [sx, nearH, label] of [[-1, wingHNL, 'L'], [1, wingHNR, 'R']]) {
      const x = sx * hw;
      let curveLen = 0;
      let prevPt = null;
      const nSegs = 12;
      for (let i = 0; i <= nSegs; i++) {
        const t = i / nSegs;
        const y = t * nearH;
        const z = domeZAtLocal(x, y, cfg, D, riserFt);
        const wp = toWorld(x, y, z);
        if (prevPt) curveLen += wp.distanceTo(prevPt);
        prevPt = wp;
      }
      const midY = nearH / 2;
      const midZ = domeZAtLocal(x, midY, cfg, D, riserFt);
      const curveLabelPos = toWorld(x + sx * 1.5, midY, midZ);
      const curveSprite = makeDimSprite(fmtFtIn(curveLen));
      curveSprite.position.copy(curveLabelPos);
      dimensionGroup.add(curveSprite);
    }

    // --- Roof slope angles ---
    for (const [sx, nearH, farH, label] of [[-1, wingHNL, wingHFL, 'L'], [1, wingHNR, wingHFR, 'R']]) {
      const slopeAngle = Math.atan2(nearH - farH, depth) * 180 / Math.PI;
      const midY = (nearH + farH) / 2;
      const midZ = depth / 2;
      const anglePos = toWorld(sx * hw + sx * 2, midY + 1.5, midZ);
      const angleSprite = makeDimSprite(slopeAngle.toFixed(1) + '\u00B0');
      angleSprite.position.copy(anglePos);
      dimensionGroup.add(angleSprite);
    }
  }
}

// ============================================================
// INTERACTIVE HANDLES
// ============================================================
const handleGeo = new THREE.SphereGeometry(0.4, 12, 12);
const handleGeoLarge = new THREE.SphereGeometry(0.55, 12, 12);

function rebuildHandles(cfg, riserFt) {
  // Clear old handles
  while (handleGroup.children.length > 0) {
    const c = handleGroup.children[0];
    handleGroup.remove(c);
  }

  if (!editMode) return;

  // -- Riser handle (always available in edit mode) --
  {
    const h = createHandle(
      new THREE.Vector3(0, riserFt, cfg.baseRadius),
      'riser', {}
    );
    h.geometry = handleGeoLarge;
    handleGroup.add(h);
  }

  if (!showWings) return;

  const hw = wingWidthFt / 2;
  const depth = wingDepthFt;
  const Dhandle = Math.sqrt(cfg.baseRadius * cfg.baseRadius - hw * hw);
  for (const [wg, side] of [[wingGroupL, 'left'], [wingGroupR, 'right']]) {
    if (!wg) continue;

    // Far corners (4) — resize width+depth + adjust far corner heights
    for (const sx of [-1, 1]) {
      const farH = sx < 0 ? wingHFL : wingHFR;
      const localPos = new THREE.Vector3(sx * hw, farH, depth);
      const worldPos = localPos.clone().applyMatrix4(wg.matrixWorld);
      const cornerType = sx < 0 ? 'heightFL' : 'heightFR';
      const h = createHandle(worldPos, cornerType, { side, sx });
      handleGroup.add(h);
    }

    // Far edge center — adjust depth only
    {
      const avgFarH = (wingHFL + wingHFR) / 2;
      const localPos = new THREE.Vector3(0, avgFarH / 2, depth);
      const worldPos = localPos.clone().applyMatrix4(wg.matrixWorld);
      const h = createHandle(worldPos, 'depth', { side });
      handleGroup.add(h);
    }

    // Side edge centers (2) — adjust width only
    for (const sx of [-1, 1]) {
      const nearH = sx < 0 ? wingHNL : wingHNR;
      const farH = sx < 0 ? wingHFL : wingHFR;
      const midH = (nearH + farH) / 2;
      const localPos = new THREE.Vector3(sx * hw, midH / 2, depth / 2);
      const worldPos = localPos.clone().applyMatrix4(wg.matrixWorld);
      const h = createHandle(worldPos, 'width', { side, sx });
      handleGroup.add(h);
    }

    // Near corner handles — one per side at dome edge, adjust near heights
    for (const sx of [-1, 1]) {
      const nearH = sx < 0 ? wingHNL : wingHNR;
      const handleX = sx * hw * 0.7;
      const handleZ = domeZAtLocal(handleX, nearH, cfg, Dhandle, riserFt);
      const localPos = new THREE.Vector3(handleX, nearH, handleZ);
      const worldPos = localPos.clone().applyMatrix4(wg.matrixWorld);
      const heightType = sx < 0 ? 'heightNL' : 'heightNR';
      const h = createHandle(worldPos, heightType, { side });
      h.geometry = handleGeoLarge;
      handleGroup.add(h);
    }

    // Wing body handle (on roof midpoint) — adjust angle/splay
    {
      const avgH = (wingHNL + wingHNR + wingHFL + wingHFR) / 4;
      const localPos = new THREE.Vector3(0, avgH + 0.5, depth / 2);
      const worldPos = localPos.clone().applyMatrix4(wg.matrixWorld);
      const h = createHandle(worldPos, 'angle', { side });
      h.geometry = handleGeoLarge;
      handleGroup.add(h);
    }

    // Roof overhang handle — at far edge of roof overhang
    {
      const avgFarH = (wingHFL + wingHFR) / 2;
      const localPos = new THREE.Vector3(0, avgFarH + 0.5, depth + roofOverhangFt);
      const worldPos = localPos.clone().applyMatrix4(wg.matrixWorld);
      const h = createHandle(worldPos, 'roofOverhang', { side });
      handleGroup.add(h);
    }

    // Wing arc handle — at midpoint of inner wall, offset by arc bulge
    {
      const innerSx = (side === 'left') ? -1 : 1;
      // Determine which side is the inner side based on wing angle placement
      // Place handle at inner wall midpoint along depth
      const innerX = innerSx * hw;
      const nearH = innerSx < 0 ? wingHNL : wingHNR;
      const farH = innerSx < 0 ? wingHFL : wingHFR;
      const midH = (nearH + farH) / 2;
      const localPos = new THREE.Vector3(innerX, midH / 2, depth * 0.5);
      const worldPos = localPos.clone().applyMatrix4(wg.matrixWorld);
      const h = createHandle(worldPos, 'wingArc', { side });
      handleGroup.add(h);
    }
  }

  // -- Canopy handles (depth + entry gap) --
  const rAtCanopy = domeRadiusAtY(Math.min(wingHNL, wingHNR), cfg, riserFt);
  if (rAtCanopy > 1) {
    const rOuter = rAtCanopy + canopyDepthFt;
    // Canopy depth handles — at outer edge of each canopy, midpoint of sweep
    for (const [cw, sideSign] of [[canopyWrapL, +1], [canopyWrapR, -1]]) {
      if (!cw || cw.children.length === 0) continue;
      // Midpoint angle: halfway between wing junction and entry gap
      const gapTheta = Math.asin(Math.min(0.95, entryWidth / (2 * rAtCanopy)));
      const wingTheta = sideSign > 0 ? Math.PI * 0.3 : -Math.PI * 0.3; // approximate
      const midTheta = (gapTheta * sideSign + wingTheta) / 2;
      // Use a simpler approach: place at the gap-side edge, outer radius
      const theta = gapTheta * sideSign;
      const h = createHandle(
        new THREE.Vector3(rOuter * Math.sin(theta), Math.min(wingHNL, wingHNR) - 0.3, rOuter * Math.cos(theta)),
        'canopyDepth', { side: sideSign > 0 ? 'left' : 'right' }
      );
      handleGroup.add(h);
    }

    // Entry width handle — at canopy tip, one handle controls both sides
    {
      const gapTheta = Math.asin(Math.min(0.95, entryWidth / (2 * rAtCanopy)));
      const rMid = (rAtCanopy + rOuter) / 2;
      const h = createHandle(
        new THREE.Vector3(rMid * Math.sin(gapTheta), Math.min(wingHNL, wingHNR) - 0.3, rMid * Math.cos(gapTheta)),
        'entryWidth', {}
      );
      handleGroup.add(h);
    }
  }
}

function createHandle(position, type, data) {
  const mesh = new THREE.Mesh(handleGeo, handleMaterial.clone());
  mesh.position.copy(position);
  mesh.renderOrder = 999;
  mesh.userData.handleType = type;
  mesh.userData.handleData = data;
  return mesh;
}

// Octagon side drag handles
function rebuildOctHandles(cfg, riserFt) {
  while (octHandleGroup.children.length > 0) {
    octHandleGroup.remove(octHandleGroup.children[0]);
  }
  if (!octagonalBase || !editMode) return;

  const midY = riserFt / 2;
  for (let i = 0; i < OCT_N; i++) {
    const mp = getOctSideMidpoint(i, cfg.baseRadius);
    const h = createHandle(
      new THREE.Vector3(mp.x, midY, mp.z),
      'octSide', { sideIndex: i }
    );
    h.geometry = handleGeoLarge;
    octHandleGroup.add(h);
  }
}

// ============================================================
// DRAG INTERACTION LOGIC
// ============================================================
function getMouseWorldOnPlane(event, plane) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const target = new THREE.Vector3();
  const hit = raycaster.ray.intersectPlane(plane, target);
  return hit ? target : null;
}

function getFloorIntersection(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  const target = new THREE.Vector3();
  const hit = raycaster.ray.intersectPlane(floorPlane, target);
  return hit ? target : null;
}

function snapToGrid(val, gridSize) {
  return Math.round(val / gridSize) * gridSize;
}

// Resolve current wing group from stored side string (avoids stale references)
function getWingGroup(side) {
  return side === 'left' ? wingGroupL : wingGroupR;
}

// Store axis directions at drag start so they survive rebuildScene()
let dragLocalX = null;
let dragLocalZ = null;

function startDrag(handle, event) {
  dragTarget = handle;
  handle.material = handleDragMaterial.clone();
  orbitControls.enabled = false;
  document.body.classList.add('cursor-grabbing');

  const type = handle.userData.handleType;
  const wg = getWingGroup(handle.userData.handleData.side);

  // Capture wing local axes at drag start (these won't change during drag)
  if (wg) {
    dragLocalX = new THREE.Vector3(1, 0, 0).transformDirection(wg.matrixWorld).normalize();
    dragLocalZ = new THREE.Vector3(0, 0, 1).transformDirection(wg.matrixWorld).normalize();
  }

  // Create drag plane based on handle type
  const isHeightType = ['heightNL','heightNR','heightFL','heightFR'].includes(type);
  if (isHeightType) {
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();
    dragPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, handle.position);
    const heightMap = { heightNL: wingHNL, heightNR: wingHNR, heightFL: wingHFL, heightFR: wingHFR };
    dragStartValue = heightMap[type];
  } else if (type === 'depth') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = wingDepthFt;
  } else if (type === 'width') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = wingWidthFt;
  } else if (type === 'corner') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = { width: wingWidthFt, depth: wingDepthFt };
  } else if (type === 'angle') {
    // Use floor plane for angle dragging (more intuitive)
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    dragStartValue = wingAngleDeg;
  } else if (type === 'octSide') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = octSideFractions[handle.userData.handleData.sideIndex];
  } else if (type === 'riser') {
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();
    dragPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, handle.position);
    dragStartValue = riserHeightInches;
  } else if (type === 'roofOverhang') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = roofOverhangFt;
  } else if (type === 'wingArc') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = wingArcDiameter;
  } else if (type === 'canopyDepth') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = canopyDepthFt;
  } else if (type === 'entryWidth') {
    dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -handle.position.y);
    dragStartValue = entryWidth;
  }

  // Get initial intersection
  dragStartPoint = getMouseWorldOnPlane(event, dragPlane);
}

function updateDrag(event) {
  if (!dragTarget || !dragPlane || !dragStartPoint) return;

  const currentPoint = getMouseWorldOnPlane(event, dragPlane);
  if (!currentPoint) return;

  const type = dragTarget.userData.handleType;
  const side = dragTarget.userData.handleData.side;

  const isHeightType = ['heightNL','heightNR','heightFL','heightFR'].includes(type);
  if (isHeightType) {
    const deltaY = currentPoint.y - dragStartPoint.y;
    const minH = type.startsWith('heightN') ? 6 : 4;
    const newVal = Math.round(Math.min(24, Math.max(minH, dragStartValue + deltaY)) * 4) / 4;
    const stateMap = { heightNL: 'wingHNL', heightNR: 'wingHNR', heightFL: 'wingHFL', heightFR: 'wingHFR' };
    const sliderMap = { heightNL: 'wing-hnl', heightNR: 'wing-hnr', heightFL: 'wing-hfl', heightFR: 'wing-hfr' };
    // Update state
    if (type === 'heightNL') wingHNL = newVal;
    else if (type === 'heightNR') wingHNR = newVal;
    else if (type === 'heightFL') wingHFL = newVal;
    else if (type === 'heightFR') wingHFR = newVal;
    const prefix = sliderMap[type];
    document.getElementById(prefix + '-slider').value = newVal;
    document.getElementById(prefix + '-value').textContent = fmtFtIn(newVal);
  } else if (type === 'depth') {
    // Use stored local Z axis from drag start
    const worldDelta = currentPoint.clone().sub(dragStartPoint);
    const deltaZ = worldDelta.dot(dragLocalZ);
    wingDepthFt = Math.round(Math.min(40, Math.max(10, dragStartValue + deltaZ)) * 4) / 4;
    document.getElementById('wing-depth-slider').value = wingDepthFt;
    document.getElementById('wing-depth-value').textContent = fmtFtIn(wingDepthFt);
  } else if (type === 'width') {
    // Use stored local X axis from drag start
    const worldDelta = currentPoint.clone().sub(dragStartPoint);
    const deltaX = worldDelta.dot(dragLocalX);
    const sx = dragTarget.userData.handleData.sx;
    wingWidthFt = Math.round(Math.min(24, Math.max(8, dragStartValue + deltaX * sx * 2)) * 2) / 2;
    document.getElementById('wing-width-slider').value = wingWidthFt;
    document.getElementById('wing-width-value').textContent = fmtFtIn(wingWidthFt);
  } else if (type === 'corner') {
    // Use stored local axes from drag start
    const worldDelta = currentPoint.clone().sub(dragStartPoint);
    const deltaX = worldDelta.dot(dragLocalX);
    const deltaZ = worldDelta.dot(dragLocalZ);
    const sx = dragTarget.userData.handleData.sx;
    wingWidthFt = Math.round(Math.min(24, Math.max(8, dragStartValue.width + deltaX * sx * 2)) * 2) / 2;
    wingDepthFt = Math.round(Math.min(40, Math.max(10, dragStartValue.depth + deltaZ)) * 4) / 4;
    document.getElementById('wing-width-slider').value = wingWidthFt;
    document.getElementById('wing-width-value').textContent = fmtFtIn(wingWidthFt);
    document.getElementById('wing-depth-slider').value = wingDepthFt;
    document.getElementById('wing-depth-value').textContent = fmtFtIn(wingDepthFt);
  } else if (type === 'angle') {
    // Compute angular delta from dome center on XZ plane
    const currentAngle = Math.atan2(currentPoint.x, currentPoint.z);
    const startAngle = Math.atan2(dragStartPoint.x, dragStartPoint.z);
    let deltaDeg = (currentAngle - startAngle) * 180 / Math.PI;
    // Normalize to -180..180
    if (deltaDeg > 180) deltaDeg -= 360;
    if (deltaDeg < -180) deltaDeg += 360;
    // Left wing: positive mouse angle = decrease splay; Right wing: positive = increase splay
    const sign = (side === 'left') ? -1 : 1;
    wingAngleDeg = Math.round(((dragStartValue + deltaDeg * sign) % 360 + 360) % 360);
    document.getElementById('wing-angle-slider').value = wingAngleDeg;
    document.getElementById('wing-angle-value').innerHTML = wingAngleDeg + '&deg;';
  } else if (type === 'octSide') {
    const idx = dragTarget.userData.handleData.sideIndex;
    const sideAngle = octSideAngle(idx);
    const radialDir = new THREE.Vector3(Math.cos(sideAngle), 0, Math.sin(sideAngle));
    const worldDelta = currentPoint.clone().sub(dragStartPoint);
    const radialDelta = worldDelta.dot(radialDir);
    const cfg = DOME_CONFIGS[currentDomeKey];
    const defaultApothem = cfg.baseRadius * Math.cos(Math.PI / OCT_N);
    const deltaFraction = radialDelta / defaultApothem;
    octSideFractions[idx] = Math.max(0.5, Math.min(1.5, dragStartValue + deltaFraction));
  } else if (type === 'riser') {
    const deltaY = currentPoint.y - dragStartPoint.y;
    // Convert feet of drag to inches (riser is stored in inches, 0-120)
    const newVal = Math.round(Math.min(120, Math.max(0, dragStartValue + deltaY * 12)) / 0.5) * 0.5;
    riserHeightInches = newVal;
    document.getElementById('riser-slider').value = newVal;
    document.getElementById('riser-value').textContent = newVal + '"';
  } else if (type === 'roofOverhang') {
    const worldDelta = currentPoint.clone().sub(dragStartPoint);
    const deltaZ = worldDelta.dot(dragLocalZ);
    roofOverhangFt = Math.round(Math.min(8, Math.max(0, dragStartValue + deltaZ)) * 4) / 4;
    document.getElementById('roof-overhang-slider').value = roofOverhangFt;
    document.getElementById('roof-overhang-value').textContent = fmtFtIn(roofOverhangFt);
  } else if (type === 'wingArc') {
    const worldDelta = currentPoint.clone().sub(dragStartPoint);
    const deltaX = worldDelta.dot(dragLocalX);
    const sideData = dragTarget.userData.handleData.side;
    // Dragging the inner wall outward (away from dome center) increases arc diameter
    const sign = (sideData === 'left') ? -1 : 1;
    wingArcDiameter = Math.round(Math.min(500, Math.max(0, dragStartValue + deltaX * sign * 20)) / 5) * 5;
    document.getElementById('wing-arc-slider').value = wingArcDiameter;
    document.getElementById('wing-arc-value').textContent = wingArcDiameter === 0 ? 'Dome' : fmtFtIn(wingArcDiameter);
  } else if (type === 'canopyDepth') {
    // Radial drag: compute delta in radial direction from dome center
    const worldDelta = currentPoint.clone().sub(dragStartPoint);
    const handlePos = dragTarget.position;
    const radialDir = new THREE.Vector3(handlePos.x, 0, handlePos.z).normalize();
    const deltaR = worldDelta.dot(radialDir);
    canopyDepthFt = Math.round(Math.min(10, Math.max(3, dragStartValue + deltaR)) * 2) / 2;
    document.getElementById('canopy-depth-slider').value = canopyDepthFt;
    document.getElementById('canopy-depth-value').textContent = fmtFtIn(canopyDepthFt);
  } else if (type === 'entryWidth') {
    // Lateral drag along X changes entry width
    const deltaX = currentPoint.x - dragStartPoint.x;
    entryWidth = Math.round(Math.min(12, Math.max(4, dragStartValue + deltaX * 2)) * 2) / 2;
    document.getElementById('entry-width-slider').value = entryWidth;
    document.getElementById('entry-width-value').textContent = fmtFtIn(entryWidth);
  }

  rebuildScene();
}

function endDrag() {
  if (dragTarget) {
    dragTarget.material = handleMaterial.clone();
  }
  dragTarget = null;
  dragPlane = null;
  dragStartPoint = null;
  dragStartValue = null;
  dragLocalX = null;
  dragLocalZ = null;
  if (!walkMode) orbitControls.enabled = true;
  document.body.classList.remove('cursor-grabbing');
}

// ============================================================
// ROOM DRAWING LOGIC
// ============================================================
function getCeilingHeightAt(x, z) {
  // Raycast straight up from (x, 0.1, z) to find ceiling above this point
  const origin = new THREE.Vector3(x, 0.1, z);
  const direction = new THREE.Vector3(0, 1, 0);
  const rc = new THREE.Raycaster(origin, direction, 0, 100);

  // Collect all meshes to test against (dome, wings, riser walls)
  const targets = [];
  domeGroup.traverse(c => { if (c.isMesh) targets.push(c); });
  if (wingGroupL) wingGroupL.traverse(c => { if (c.isMesh) targets.push(c); });
  if (wingGroupR) wingGroupR.traverse(c => { if (c.isMesh) targets.push(c); });

  const hits = rc.intersectObjects(targets, false);
  if (hits.length > 0) {
    return hits[0].point.y;
  }
  return null; // no ceiling found
}

function rebuildCustomWalls() {
  // Clear old walls
  while (customWallGroup.children.length > 0) {
    const c = customWallGroup.children[0];
    customWallGroup.remove(c);
    if (c.geometry) c.geometry.dispose();
  }
  while (wallEndpointGroup.children.length > 0) {
    const c = wallEndpointGroup.children[0];
    wallEndpointGroup.remove(c);
    if (c.geometry) c.geometry.dispose();
  }
  while (wallTopHandleGroup.children.length > 0) {
    const c = wallTopHandleGroup.children[0];
    wallTopHandleGroup.remove(c);
    if (c.geometry) c.geometry.dispose();
  }

  const endpointGeo = new THREE.SphereGeometry(0.3, 8, 8);
  const topHandleGeo = new THREE.SphereGeometry(0.25, 8, 8);

  for (let i = 0; i < customWalls.length; i++) {
    const w = customWalls[i];
    if (w.thickness === undefined) w.thickness = 0.2;
    const dx = w.x2 - w.x1;
    const dz = w.z2 - w.z1;
    const length = Math.sqrt(dx * dx + dz * dz);
    if (length < 0.1) continue;

    // Auto-height: raycast to find ceiling
    if (w.autoHeight !== false) {
      const midX = (w.x1 + w.x2) / 2;
      const midZ = (w.z1 + w.z2) / 2;
      const ceilingY = getCeilingHeightAt(midX, midZ);
      if (ceilingY !== null) {
        w.height = Math.max(1, ceilingY - 0.5);
      } else {
        w.height = 8;
      }
    }

    const wallH = w.height || 8;
    const geo = new THREE.BoxGeometry(length, wallH, w.thickness);
    const mesh = new THREE.Mesh(geo, partitionWallMaterial.clone());
    mesh.position.set((w.x1 + w.x2) / 2, wallH / 2, (w.z1 + w.z2) / 2);
    mesh.rotation.y = Math.atan2(dx, dz);
    mesh.userData.customWallIndex = i;
    customWallGroup.add(mesh);

    // Endpoint handles (only in draw rooms mode)
    if (drawRoomsMode) {
      for (const [ex, ez, epIdx] of [[w.x1, w.z1, 0], [w.x2, w.z2, 1]]) {
        const ep = new THREE.Mesh(endpointGeo, wallEndpointMaterial.clone());
        ep.position.set(ex, 0.3, ez);
        ep.renderOrder = 999;
        ep.userData.wallEndpoint = true;
        ep.userData.wallIndex = i;
        ep.userData.endpointIndex = epIdx;
        wallEndpointGroup.add(ep);
      }

      // Top-edge height handle at wall top center
      const th = new THREE.Mesh(topHandleGeo, handleMaterial.clone());
      th.position.set((w.x1 + w.x2) / 2, wallH, (w.z1 + w.z2) / 2);
      th.renderOrder = 999;
      th.userData.wallTopHandle = true;
      th.userData.wallIndex = i;
      wallTopHandleGroup.add(th);
    }
  }
}

function addCustomWall(x1, z1, x2, z2) {
  customWalls.push({ x1, z1, x2, z2, height: 8, autoHeight: true, thickness: 0.5 });
  rebuildCustomWalls();
}

function removeCustomWall(index) {
  customWalls.splice(index, 1);
  rebuildCustomWalls();
}

// ============================================================
// POINTER EVENT HANDLERS
// ============================================================
let pointerDownTime = 0;
let pointerDownPos = { x: 0, y: 0 };
let wallEndpointDrag = null; // {wallIndex, endpointIndex}
let wallBodyDrag = null;     // {wallIndex, startPoint, startX1, startZ1, startX2, startZ2}
let wallTopDrag = null;      // {wallIndex, dragPlane, startPoint, startHeight}
let hoveredWallMesh = null;  // currently hovered custom wall mesh

function onPointerDown(event) {
  // Ignore if clicking on UI
  if (event.target !== renderer.domElement) return;

  pointerDownTime = Date.now();
  pointerDownPos = { x: event.clientX, y: event.clientY };

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  // Check for handle hits in edit mode (wing handles + octagon handles)
  if (editMode) {
    const allHandles = [];
    if (handleGroup.visible) allHandles.push(...handleGroup.children);
    if (octHandleGroup.visible) allHandles.push(...octHandleGroup.children);
    if (allHandles.length > 0) {
      const hits = raycaster.intersectObjects(allHandles, false);
      if (hits.length > 0) {
        startDrag(hits[0].object, event);
        event.preventDefault();
        return;
      }
    }
  }

  // Check for wall top-handle drag in draw rooms mode
  if (drawRoomsMode && wallTopHandleGroup.children.length > 0) {
    const hits = raycaster.intersectObjects(wallTopHandleGroup.children, false);
    if (hits.length > 0) {
      const th = hits[0].object;
      const wi = th.userData.wallIndex;
      const w = customWalls[wi];
      // Camera-facing vertical drag plane (same pattern as wing height handles)
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      camDir.y = 0;
      camDir.normalize();
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, th.position);
      const startPt = getMouseWorldOnPlane(event, plane);
      if (startPt) {
        wallTopDrag = {
          wallIndex: wi,
          dragPlane: plane,
          startPoint: startPt,
          startHeight: w.height || 8
        };
        th.material = handleDragMaterial.clone();
        orbitControls.enabled = false;
        document.body.classList.add('cursor-grabbing');
        event.preventDefault();
        return;
      }
    }
  }

  // Check for wall endpoint drag in draw rooms mode
  if (drawRoomsMode && wallEndpointGroup.children.length > 0) {
    const hits = raycaster.intersectObjects(wallEndpointGroup.children, false);
    if (hits.length > 0) {
      const ep = hits[0].object;
      wallEndpointDrag = {
        wallIndex: ep.userData.wallIndex,
        endpointIndex: ep.userData.endpointIndex
      };
      orbitControls.enabled = false;
      document.body.classList.add('cursor-grabbing');
      event.preventDefault();
      return;
    }
  }

  // Check for wall body drag in draw rooms mode (after endpoint/handle checks)
  if (drawRoomsMode && !drawingWall) {
    const wallMeshes = customWallGroup.children.filter(c => c.userData.customWallIndex !== undefined);
    if (wallMeshes.length > 0) {
      const hits = raycaster.intersectObjects(wallMeshes, false);
      if (hits.length > 0) {
        const wi = hits[0].object.userData.customWallIndex;
        const w = customWalls[wi];
        const floorPt = getFloorIntersection(event);
        if (floorPt) {
          wallBodyDrag = {
            wallIndex: wi,
            startPoint: floorPt.clone(),
            startX1: w.x1, startZ1: w.z1,
            startX2: w.x2, startZ2: w.z2
          };
          orbitControls.enabled = false;
          document.body.classList.add('cursor-grabbing');
          event.preventDefault();
          return;
        }
      }
    }
  }
}

function onPointerMove(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // Handle active drag
  if (dragTarget) {
    updateDrag(event);
    return;
  }

  // Handle wall top-handle drag (vertical height resize)
  if (wallTopDrag) {
    const currentPt = getMouseWorldOnPlane(event, wallTopDrag.dragPlane);
    if (currentPt) {
      const deltaY = currentPt.y - wallTopDrag.startPoint.y;
      const w = customWalls[wallTopDrag.wallIndex];
      // Compute ceiling limit at wall center
      const midX = (w.x1 + w.x2) / 2;
      const midZ = (w.z1 + w.z2) / 2;
      const ceilingY = getCeilingHeightAt(midX, midZ);
      const maxH = ceilingY !== null ? ceilingY - 0.25 : 30;
      w.height = Math.max(1, Math.min(maxH, wallTopDrag.startHeight + deltaY));
      w.autoHeight = false;
      rebuildCustomWalls();
    }
    return;
  }

  // Handle wall endpoint drag
  if (wallEndpointDrag) {
    const floorPt = getFloorIntersection(event);
    if (floorPt) {
      const w = customWalls[wallEndpointDrag.wallIndex];
      const snappedX = snapToGrid(floorPt.x, 0.5);
      const snappedZ = snapToGrid(floorPt.z, 0.5);
      if (wallEndpointDrag.endpointIndex === 0) {
        w.x1 = snappedX;
        w.z1 = snappedZ;
      } else {
        w.x2 = snappedX;
        w.z2 = snappedZ;
      }
      rebuildCustomWalls();
    }
    return;
  }

  // Handle wall body drag (translate whole wall)
  if (wallBodyDrag) {
    const floorPt = getFloorIntersection(event);
    if (floorPt) {
      const dx = floorPt.x - wallBodyDrag.startPoint.x;
      const dz = floorPt.z - wallBodyDrag.startPoint.z;
      const w = customWalls[wallBodyDrag.wallIndex];
      w.x1 = snapToGrid(wallBodyDrag.startX1 + dx, 0.5);
      w.z1 = snapToGrid(wallBodyDrag.startZ1 + dz, 0.5);
      w.x2 = snapToGrid(wallBodyDrag.startX2 + dx, 0.5);
      w.z2 = snapToGrid(wallBodyDrag.startZ2 + dz, 0.5);
      rebuildCustomWalls();
    }
    return;
  }

  // Update draw preview line
  if (drawRoomsMode && drawingWall) {
    const floorPt = getFloorIntersection(event);
    if (floorPt) {
      const snappedX = snapToGrid(floorPt.x, 0.5);
      const snappedZ = snapToGrid(floorPt.z, 0.5);
      // Update or create preview line
      if (drawPreviewLine) {
        scene.remove(drawPreviewLine);
        drawPreviewLine.geometry.dispose();
      }
      const points = [
        new THREE.Vector3(drawingWall.x1, 0.1, drawingWall.z1),
        new THREE.Vector3(snappedX, 0.1, snappedZ)
      ];
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      drawPreviewLine = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x66aaff, linewidth: 2 }));
      scene.add(drawPreviewLine);
    }
    return;
  }

  // Hover feedback on handles
  if (editMode) {
    const allHandles = [];
    if (handleGroup.visible) allHandles.push(...handleGroup.children);
    if (octHandleGroup.visible) allHandles.push(...octHandleGroup.children);
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(allHandles, false);

    if (hoveredHandle && hoveredHandle !== dragTarget) {
      hoveredHandle.material = handleMaterial.clone();
    }

    if (hits.length > 0 && hits[0].object !== dragTarget) {
      hoveredHandle = hits[0].object;
      hoveredHandle.material = handleHoverMaterial.clone();
      if (!document.body.classList.contains('cursor-grabbing')) {
        document.body.classList.add('cursor-grab');
      }
    } else {
      hoveredHandle = null;
      document.body.classList.remove('cursor-grab');
    }
  }

  // Hover feedback on custom wall meshes (draw rooms mode)
  if (drawRoomsMode && !drawingWall && !wallEndpointDrag && !wallBodyDrag && !wallTopDrag) {
    raycaster.setFromCamera(mouse, camera);

    // Check top handles first
    if (wallTopHandleGroup.children.length > 0) {
      const thHits = raycaster.intersectObjects(wallTopHandleGroup.children, false);
      if (thHits.length > 0) {
        // Restore previous hovered wall
        if (hoveredWallMesh) {
          hoveredWallMesh.material.emissive.setHex(0x000000);
          hoveredWallMesh = null;
        }
        document.body.classList.add('cursor-grab');
        return;
      }
    }

    // Check wall meshes
    const wallMeshes = customWallGroup.children.filter(c => c.userData.customWallIndex !== undefined);
    const wallHits = raycaster.intersectObjects(wallMeshes, false);

    // Restore previous hovered wall
    if (hoveredWallMesh) {
      hoveredWallMesh.material.emissive.setHex(0x000000);
      hoveredWallMesh = null;
    }

    if (wallHits.length > 0) {
      hoveredWallMesh = wallHits[0].object;
      hoveredWallMesh.material.emissive.setHex(0x222211);
      if (!document.body.classList.contains('cursor-grabbing')) {
        document.body.classList.add('cursor-grab');
      }
    } else {
      document.body.classList.remove('cursor-grab');
    }
  }
}

function onPointerUp(event) {
  const elapsed = Date.now() - pointerDownTime;
  const dist = Math.hypot(event.clientX - pointerDownPos.x, event.clientY - pointerDownPos.y);
  const isClick = elapsed < 300 && dist < 5;

  // End handle drag
  if (dragTarget) {
    endDrag();
    return;
  }

  // End wall top-handle drag
  if (wallTopDrag) {
    wallTopDrag = null;
    if (!walkMode) orbitControls.enabled = true;
    document.body.classList.remove('cursor-grabbing');
    rebuildCustomWalls(); // refresh handle materials
    return;
  }

  // End wall endpoint drag
  if (wallEndpointDrag) {
    wallEndpointDrag = null;
    if (!walkMode) orbitControls.enabled = true;
    document.body.classList.remove('cursor-grabbing');
    return;
  }

  // End wall body drag
  if (wallBodyDrag) {
    wallBodyDrag = null;
    if (!walkMode) orbitControls.enabled = true;
    document.body.classList.remove('cursor-grabbing');
    return;
  }

  // Room drawing: click to place wall points
  if (drawRoomsMode && isClick && event.target === renderer.domElement) {
    const floorPt = getFloorIntersection(event);
    if (floorPt) {
      const snappedX = snapToGrid(floorPt.x, 0.5);
      const snappedZ = snapToGrid(floorPt.z, 0.5);

      if (!drawingWall) {
        // First click: start wall
        drawingWall = { x1: snappedX, z1: snappedZ };
      } else {
        // Second click: complete wall
        addCustomWall(drawingWall.x1, drawingWall.z1, snappedX, snappedZ);
        drawingWall = null;
        if (drawPreviewLine) {
          scene.remove(drawPreviewLine);
          drawPreviewLine.geometry.dispose();
          drawPreviewLine = null;
        }
      }
    }
  }
}

function onDblClick(event) {
  if (!drawRoomsMode) return;
  if (event.target !== renderer.domElement) return;

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  // Check for wall hit to delete
  const wallMeshes = customWallGroup.children.filter(c => c.userData.customWallIndex !== undefined);
  const hits = raycaster.intersectObjects(wallMeshes, false);
  if (hits.length > 0) {
    const idx = hits[0].object.userData.customWallIndex;
    removeCustomWall(idx);
  }
}

renderer.domElement.addEventListener('pointerdown', onPointerDown);
renderer.domElement.addEventListener('pointermove', onPointerMove);
renderer.domElement.addEventListener('pointerup', onPointerUp);
renderer.domElement.addEventListener('dblclick', onDblClick);

// ============================================================
// BUILD/REBUILD SCENE
// ============================================================
function rebuildScene() {
  _vtxLabelPositions = [];  // clear label deconfliction registry
  const cfg = DOME_CONFIGS[currentDomeKey];
  const riserFt = riserHeightInches / 12;

  // Clear dome group
  while (domeGroup.children.length > 0) {
    const child = domeGroup.children[0];
    domeGroup.remove(child);
    if (child.geometry) child.geometry.dispose();
  }

  // Clear markers
  while (markerGroup.children.length > 0) {
    const child = markerGroup.children[0];
    markerGroup.remove(child);
    if (child.geometry) child.geometry.dispose();
    if (child.material && child.material.dispose) child.material.dispose();
  }

  // Dispose old width ring
  if (widthRingLine) { scene.remove(widthRingLine); widthRingLine.geometry.dispose(); widthRingLine = null; }
  if (collisionRingLine) { scene.remove(collisionRingLine); collisionRingLine.geometry.dispose(); collisionRingLine = null; }

  // -- Dome Shell --
  const shellGeo = createDomeShell(cfg);
  const domeMesh = new THREE.Mesh(shellGeo, domeMaterial);
  domeMesh.position.y = riserFt;
  domeMesh.castShadow = true;
  domeMesh.receiveShadow = true;
  if (cutawayMode) { domeMesh.material.clippingPlanes = [cutawayPlane]; }
  else { domeMesh.material.clippingPlanes = []; }
  domeGroup.add(domeMesh);

  // -- Geodesic Wireframe --
  const wireGeo = createGeodesicWireframe(cfg);
  const domeWireMesh = new THREE.LineSegments(wireGeo, domeWireMaterial);
  domeWireMesh.position.y = riserFt;
  domeWireMesh.visible = showWireframe;
  domeGroup.add(domeWireMesh);

  // -- Riser Wall --
  if (riserHeightInches > 0) {
    if (octagonalBase) {
      // 8 flat wall panels between octagon vertices
      const verts = getOctVertices(cfg.baseRadius);
      for (let i = 0; i < OCT_N; i++) {
        const v1 = verts[i], v2 = verts[(i + 1) % OCT_N];
        const dx = v2.x - v1.x, dz = v2.z - v1.z;
        const len = Math.sqrt(dx * dx + dz * dz);
        const wallGeo = new THREE.PlaneGeometry(len, riserFt);
        const wallMesh = new THREE.Mesh(wallGeo, riserMaterial);
        wallMesh.position.set((v1.x + v2.x) / 2, riserFt / 2, (v1.z + v2.z) / 2);
        wallMesh.rotation.y = Math.atan2(dx, dz) + Math.PI / 2;
        wallMesh.castShadow = true;
        if (cutawayMode) wallMesh.material.clippingPlanes = [cutawayPlane];
        else wallMesh.material.clippingPlanes = [];
        domeGroup.add(wallMesh);
      }
    } else {
      const riserGeo = new THREE.CylinderGeometry(cfg.baseRadius, cfg.baseRadius, riserFt, 64, 1, true);
      const riserMesh = new THREE.Mesh(riserGeo, riserMaterial);
      riserMesh.position.y = riserFt / 2;
      riserMesh.castShadow = true;
      if (cutawayMode) { riserMesh.material.clippingPlanes = [cutawayPlane]; }
      else { riserMesh.material.clippingPlanes = []; }
      domeGroup.add(riserMesh);
    }

    // Top ring (octagonal or circular)
    if (octagonalBase) {
      const verts = getOctVertices(cfg.baseRadius);
      const ringPts = verts.map(v => new THREE.Vector3(v.x, riserFt, v.z));
      ringPts.push(ringPts[0].clone());
      const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPts);
      const ringLine = new THREE.Line(ringGeo, new THREE.LineBasicMaterial({ color: 0x888899 }));
      domeGroup.add(ringLine);
    } else {
      const riserRingGeo = new THREE.RingGeometry(cfg.baseRadius - 0.05, cfg.baseRadius + 0.05, 64);
      const riserRingMat = new THREE.MeshBasicMaterial({ color: 0x888899, side: THREE.DoubleSide });
      const riserRing = new THREE.Mesh(riserRingGeo, riserRingMat);
      riserRing.rotation.x = -Math.PI / 2;
      riserRing.position.y = riserFt;
      domeGroup.add(riserRing);
    }
  }

  // -- Wings --
  rebuildWings(cfg, riserFt);

  // -- Corner Posts --
  buildCornerPosts(cfg);

  // -- Height Markers --
  rebuildMarkers(cfg, riserFt);

  // -- Width Ring at Wing Top --
  rebuildWidthRing(cfg, riserFt);

  // -- Interior --
  buildInterior(cfg, riserFt);

  // Update info panel
  updateInfoPanel(cfg, riserFt);

  // Update dome opacity
  domeMaterial.opacity = domeOpacity;
  domeMaterial.transparent = domeOpacity < 0.95;
  domeMaterial.depthWrite = domeOpacity >= 0.95;

  // Rebuild dimension annotations
  buildWingDimensions(cfg, riserFt);

  // Rebuild interactive handles
  rebuildHandles(cfg, riserFt);
  rebuildOctHandles(cfg, riserFt);
  octHandleGroup.visible = octagonalBase && editMode;

  // Rebuild custom walls
  rebuildCustomWalls();

  // Capture undo snapshot (debounced to coalesce slider/drag updates)
  if (!undoStack._restoring) {
    clearTimeout(_undoDebounceTimer);
    _undoDebounceTimer = setTimeout(() => undoStack.push(getState()), 300);
  }
}

// ============================================================
// WINGS
// ============================================================
function rebuildWings(cfg, riserFt) {
  // Remove old wing groups
  if (wingGroupL) { scene.remove(wingGroupL); disposeGroup(wingGroupL); wingGroupL = null; }
  if (wingGroupR) { scene.remove(wingGroupR); disposeGroup(wingGroupR); wingGroupR = null; }
  if (canopyWrapL) { scene.remove(canopyWrapL); disposeGroup(canopyWrapL); canopyWrapL = null; }
  if (canopyWrapR) { scene.remove(canopyWrapR); disposeGroup(canopyWrapR); canopyWrapR = null; }
  if (entryBoxGroup) { scene.remove(entryBoxGroup); disposeGroup(entryBoxGroup); entryBoxGroup = null; }

  if (!showWings) return;

  // Collision check: use the tallest corner for dome width check
  const wingMaxHeight = Math.max(wingHNL, wingHNR, wingHFL, wingHFR);
  const widthAtWingTop = domeWidthAtHeight(cfg, wingMaxHeight, riserFt);
  const fits = widthAtWingTop >= wingWidthFt;

  // Compute wing placement angle — needed before buildWingStructure for innerSide
  // Position wings on dome so near-entry corner aligns flush with entry vestibule edge.
  // Entry vestibule is 8' wide, so outer edge is at 4' from center + small gap.
  const entryOuterX = entryWidth / 2 + 0.5;  // half entry-box width + clearance
  const storeOuterX = entryOuterX;
  const r = cfg.baseRadius;
  const wingAngleRad = (wingAngleDeg * Math.PI) / 180;
  const hw = wingWidthFt / 2;
  const Dw = Math.sqrt(r * r - hw * hw);

  // The near-entry corner of each wing is at local (-hw, 0, 0) for right wing.
  // After positionWingOnDome with finalAngle, that corner lands on the dome circle
  // at angle (finalAngle - atan2(hw, D)) from front.
  // We want that corner's X coordinate ≈ storeOuterX at default angle.
  // Corner is on dome circle at radius r, at angle cornerAngle from +Z:
  //   r * sin(cornerAngle) = storeOuterX
  //   cornerAngle = asin(storeOuterX / r)
  // The finalAngle = cornerAngle + atan2(hw, D) (offset from corner to chord midpoint)
  // wingPlacementAngle is the BASE angle; positionWingOnDome adds splay on top.
  const storeAngle = Math.asin(Math.min(1, storeOuterX / r));
  const cornerOffset = Math.atan2(hw, Dw);
  const wingPlacementAngle = (storeAngle + cornerOffset) * 180 / Math.PI;

  // Determine which side wall is inner (dome-facing) for each wing.
  // The inner wall faces toward the entry (+Z in world space). After wing rotation
  // by finalAngle, the sign tells us which local x direction faces the front:
  //   finalAngle > 0 → local -x faces front → inner is x=-hw → innerSide = -1
  //   finalAngle < 0 → local +x faces front → inner is x=+hw → innerSide = +1
  const placementRad = (wingPlacementAngle * Math.PI) / 180;
  const finalAngleL = -placementRad + wingAngleRad;
  const finalAngleR = placementRad - wingAngleRad;
  const innerSideL = finalAngleL > 0 ? -1 : 1;
  const innerSideR = finalAngleR > 0 ? -1 : 1;

  // Compute world-space arc circle for inner walls
  // The arc spans between the far inner corners of both wings, bowing toward the entry.
  // We transform the arc center into each wing's local space.
  let arcInfoL = null, arcInfoR = null;
  if (wingArcDiameter > 0) {
    const arcR_w = wingArcDiameter / 2;
    const wDepth = wingDepthFt;

    // Wing local-to-world: wx = Dw*sin(f) + lx*cos(f) + lz*sin(f)
    //                      wz = Dw*cos(f) - lx*sin(f) + lz*cos(f)
    const cosL = Math.cos(finalAngleL), sinL = Math.sin(finalAngleL);
    const cosR = Math.cos(finalAngleR), sinR = Math.sin(finalAngleR);

    // World positions of far inner corners
    const leftFarX = Dw * sinL + innerSideL * hw * cosL + wDepth * sinL;
    const leftFarZ = Dw * cosL - innerSideL * hw * sinL + wDepth * cosL;
    const rightFarX = Dw * sinR + innerSideR * hw * cosR + wDepth * sinR;
    const rightFarZ = Dw * cosR - innerSideR * hw * sinR + wDepth * cosR;

    // Chord between far corners
    const chordDX = rightFarX - leftFarX;
    const chordDZ = rightFarZ - leftFarZ;
    const chordLen_w = Math.sqrt(chordDX * chordDX + chordDZ * chordDZ);
    const halfChord = chordLen_w / 2;

    if (arcR_w >= halfChord) {
      const dCenter = Math.sqrt(arcR_w * arcR_w - halfChord * halfChord);
      const midX = (leftFarX + rightFarX) / 2;
      const midZ = (leftFarZ + rightFarZ) / 2;

      // Perpendicular to chord pointing toward +z (front/entry)
      let perpX = -chordDZ / chordLen_w;
      let perpZ = chordDX / chordLen_w;
      if (perpZ < 0) { perpX = -perpX; perpZ = -perpZ; }

      // Center is in front of chord (toward entry), arc bows inward (concave)
      const arcCX = midX + dCenter * perpX;
      const arcCZ = midZ + dCenter * perpZ;

      // Transform arc center to each wing's local space using Ry(f)^T
      // lx = cos(f)*dx - sin(f)*dz,  lz = sin(f)*dx + cos(f)*dz
      const dxL = arcCX - Dw * sinL;
      const dzL = arcCZ - Dw * cosL;
      const localCxL = cosL * dxL - sinL * dzL;
      const localCzL = sinL * dxL + cosL * dzL;

      const dxR = arcCX - Dw * sinR;
      const dzR = arcCZ - Dw * cosR;
      const localCxR = cosR * dxR - sinR * dzR;
      const localCzR = sinR * dxR + cosR * dzR;

      arcInfoL = { cx: localCxL, cz: localCzL, R: arcR_w };
      arcInfoR = { cx: localCxR, cz: localCzR, R: arcR_w };
    }
  }

  // Build wing structures (right wing swaps L↔R heights to mirror left wing)
  const heightsL = { hNL: wingHNL, hNR: wingHNR, hFL: wingHFL, hFR: wingHFR };
  const heightsR = { hNL: wingHNR, hNR: wingHNL, hFL: wingHFR, hFR: wingHFL };
  wingGroupL = buildWingStructure(cfg, riserFt, fits, heightsL, innerSideL, arcInfoL);
  wingGroupR = buildWingStructure(cfg, riserFt, fits, heightsR, innerSideR, arcInfoR);

  scene.add(wingGroupL);
  scene.add(wingGroupR);

  positionWingOnDome(wingGroupL, cfg, -wingPlacementAngle, 'left');
  positionWingOnDome(wingGroupR, cfg, wingPlacementAngle, 'right');

  // Need to update matrices for corner posts
  wingGroupL.updateMatrixWorld(true);
  wingGroupR.updateMatrixWorld(true);

  // Build canopy wraps (continuous roof from wing around dome toward entry)
  if (showCanopy) {
    canopyWrapL = buildCanopyWrap(cfg, riserFt, +1);
    canopyWrapR = buildCanopyWrap(cfg, riserFt, -1);
    scene.add(canopyWrapL);
    scene.add(canopyWrapR);
  }

  // Build entry box (between canopy tips at front)
  entryBoxGroup = buildEntryBox(cfg, riserFt);
  scene.add(entryBoxGroup);

  // Build connecting walls from wing inner near edges to entry box front
  if (connectWingsToEntry) {
    // Recompute entry box dimensions (same formulas as buildEntryBox)
    const canopyH = innerSideL === -1 ? wingHNL : wingHNR;
    const rAtH = domeRadiusAtY(canopyH, cfg, riserFt);
    if (rAtH >= 1) {
      const halfEW = entryWidth / 2;
      const zBack = Math.sqrt(Math.max(0, rAtH * rAtH - halfEW * halfEW));
      const zFront = zBack + entryDepth;
      const roofH = canopyH;

      // Wing inner wall near vertices in wing-local space
      // Inner wall x = innerSide * hw (flat wall base; arc may shift it but near edge is close to dome)
      const iwXL = innerSideL * hw;
      const iwXR = innerSideR * hw;

      // Near-bottom and near-top z positions on dome surface
      const DwLocal = Dw;
      const zNearBotL = domeZAtLocal(iwXL, 0, cfg, DwLocal, riserFt);
      const zNearTopL = domeZAtLocal(iwXL, canopyH, cfg, DwLocal, riserFt);
      const nearHL = innerSideL === -1 ? wingHNL : wingHNR;

      const zNearBotR = domeZAtLocal(iwXR, 0, cfg, DwLocal, riserFt);
      const zNearTopR = domeZAtLocal(iwXR, canopyH, cfg, DwLocal, riserFt);
      const nearHR = innerSideR === -1 ? wingHNR : wingHNL;

      // Transform wing inner near vertices to world space
      const wingNearBotL = new THREE.Vector3(iwXL, 0, zNearBotL);
      const wingNearTopL = new THREE.Vector3(iwXL, nearHL, zNearTopL);
      wingGroupL.localToWorld(wingNearBotL);
      wingGroupL.localToWorld(wingNearTopL);

      const wingNearBotR = new THREE.Vector3(iwXR, 0, zNearBotR);
      const wingNearTopR = new THREE.Vector3(iwXR, nearHR, zNearTopR);
      wingGroupR.localToWorld(wingNearBotR);
      wingGroupR.localToWorld(wingNearTopR);

      // Entry box front wall vertices (world space)
      const entryFrontBotL = new THREE.Vector3(-halfEW, 0, zFront);
      const entryFrontTopL = new THREE.Vector3(-halfEW, roofH, zFront);
      const entryFrontBotR = new THREE.Vector3(halfEW, 0, zFront);
      const entryFrontTopR = new THREE.Vector3(halfEW, roofH, zFront);

      // Determine collision material
      const wingMaxHeight = Math.max(wingHNL, wingHNR, wingHFL, wingHFR);
      const widthAtTop = domeWidthAtHeight(cfg, wingMaxHeight, riserFt);
      const cwFits = widthAtTop >= wingWidthFt;
      const cwMat = cwFits ? wingWallMaterial : wingWallCollisionMaterial;

      // Left connecting wall: wing-L inner near → entry front left
      const cwGeoL = new THREE.BufferGeometry();
      cwGeoL.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
        wingNearBotL.x, wingNearBotL.y, wingNearBotL.z,
        entryFrontBotL.x, entryFrontBotL.y, entryFrontBotL.z,
        wingNearTopL.x, wingNearTopL.y, wingNearTopL.z,
        entryFrontTopL.x, entryFrontTopL.y, entryFrontTopL.z,
      ]), 3));
      cwGeoL.setIndex([0, 1, 2, 2, 1, 3]);
      cwGeoL.computeVertexNormals();
      const cwMeshL = new THREE.Mesh(cwGeoL, cwMat);
      cwMeshL.castShadow = true;
      cwMeshL.receiveShadow = true;
      scene.add(cwMeshL);
      // Store on entry box group for cleanup
      entryBoxGroup.add(cwMeshL);

      // Right connecting wall: wing-R inner near → entry front right
      const cwGeoR = new THREE.BufferGeometry();
      cwGeoR.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
        entryFrontBotR.x, entryFrontBotR.y, entryFrontBotR.z,
        wingNearBotR.x, wingNearBotR.y, wingNearBotR.z,
        entryFrontTopR.x, entryFrontTopR.y, entryFrontTopR.z,
        wingNearTopR.x, wingNearTopR.y, wingNearTopR.z,
      ]), 3));
      cwGeoR.setIndex([0, 1, 2, 2, 1, 3]);
      cwGeoR.computeVertexNormals();
      const cwMeshR = new THREE.Mesh(cwGeoR, cwMat);
      cwMeshR.castShadow = true;
      cwMeshR.receiveShadow = true;
      entryBoxGroup.add(cwMeshR);
    }
  }

  // Apply cutaway clipping to wing materials
  const wingMats = [wingWallMaterial, wingWallCollisionMaterial,
                    wingRoofMaterial, wingRoofCollisionMaterial,
                    wingFloorMaterial, partitionWallMaterial];
  for (const mat of wingMats) {
    mat.clippingPlanes = cutawayMode ? [cutawayPlane] : [];
  }
}

function disposeGroup(group) {
  group.traverse((child) => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (child.material.map) child.material.map.dispose();
      if (child.material.dispose) child.material.dispose();
    }
  });
}

// ============================================================
// HEIGHT MARKERS
// ============================================================
function rebuildMarkers(cfg, riserFt) {
  if (!showMarkers) return;

  const totalHeight = riserFt + cfg.shellHeight;
  const markerHeights = [];

  for (let h = 5; h <= Math.ceil(totalHeight); h += 5) {
    markerHeights.push(h);
  }
  if (riserFt > 0 && !markerHeights.includes(Math.round(riserFt))) {
    markerHeights.push(riserFt);
  }

  for (const h of markerHeights) {
    if (h > totalHeight + 1) continue;
    const width = domeWidthAtHeight(cfg, h, riserFt);
    const halfW = Math.max(width / 2, 0.5);

    const points = [new THREE.Vector3(-halfW - 2, h, 0), new THREE.Vector3(halfW + 2, h, 0)];
    const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeo, markerMaterial);
    markerGroup.add(line);

    const label = makeTextSprite(`${Math.round(h)}'`);
    if (label) { label.position.set(halfW + 3.5, h, 0); markerGroup.add(label); }
  }
}

// ============================================================
// WIDTH RING AT WING TOP
// ============================================================
function rebuildWidthRing(cfg, riserFt) {
  if (widthRingLine) { scene.remove(widthRingLine); widthRingLine.geometry.dispose(); widthRingLine = null; }
  if (collisionRingLine) { scene.remove(collisionRingLine); collisionRingLine.geometry.dispose(); collisionRingLine = null; }

  if (!showWidthRing || !showWings) return;

  const wingMaxHRing = Math.max(wingHNL, wingHNR, wingHFL, wingHFR);
  const widthAtWingTop = domeWidthAtHeight(cfg, wingMaxHRing, riserFt);
  const fits = widthAtWingTop >= wingWidthFt;
  const halfW = widthAtWingTop / 2;

  if (widthAtWingTop <= 0) return;

  const ringPoints = [];
  const segments = 64;
  for (let i = 0; i <= segments; i++) {
    const angle = (i / segments) * Math.PI * 2;
    ringPoints.push(new THREE.Vector3(halfW * Math.cos(angle), wingMaxHRing, halfW * Math.sin(angle)));
  }

  const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPoints);
  widthRingLine = new THREE.Line(ringGeo, fits ? ringFitMaterial : ringCollisionMaterial);
  scene.add(widthRingLine);
}

// ============================================================
// TEXT SPRITES
// ============================================================
function makeTextSprite(text) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 128;
  canvas.height = 48;
  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
  ctx.font = '24px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, 64, 24);

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(3, 1.2, 1);
  return sprite;
}

// ============================================================
// INFO PANEL UPDATE
// ============================================================
function updateInfoPanel(cfg, riserFt) {
  const wingMaxHInfo = Math.max(wingHNL, wingHNR, wingHFL, wingHFR);
  const widthAtWingTop = domeWidthAtHeight(cfg, wingMaxHInfo, riserFt);
  const totalClearanceFt = widthAtWingTop - wingWidthFt;
  const clearancePerSideInches = (totalClearanceFt / 2) * 12;
  const fits = totalClearanceFt >= 0;

  const minRiser = minRiserInches(cfg, wingMaxHInfo, wingWidthFt);

  document.getElementById('info-dome-width').textContent = `${widthAtWingTop.toFixed(2)} ft (${fmtFtIn(widthAtWingTop)})`;
  document.getElementById('info-req-width').textContent = `${wingWidthFt.toFixed(1)} ft`;

  if (fits) {
    document.getElementById('info-clearance').textContent = `${fmtInches(clearancePerSideInches)} per side`;
    document.getElementById('info-clearance').style.color = '#44dd88';
  } else {
    document.getElementById('info-clearance').textContent = `${fmtInches(-clearancePerSideInches)} collision per side`;
    document.getElementById('info-clearance').style.color = '#ff6666';
  }

  if (minRiser === Infinity) {
    document.getElementById('info-min-riser').textContent = 'Impossible (dome too small)';
  } else if (minRiser <= 0) {
    document.getElementById('info-min-riser').textContent = '0" (no riser needed)';
  } else {
    document.getElementById('info-min-riser').textContent = `${minRiser.toFixed(1)}"`;
  }

  // Total area calculation
  const domeArea = Math.PI * cfg.baseRadius * cfg.baseRadius; // ~855 sq ft for 33'
  const wingArea = wingWidthFt * wingDepthFt; // full 16x24 = 384 per wing
  const totalArea = Math.round(domeArea + wingArea * 2); // dome + 2 wings
  document.getElementById('info-total-area').textContent = `~${totalArea} sq ft`;

  const badge = document.getElementById('status-badge');
  if (fits) {
    badge.textContent = `FITS: ${fmtInches(clearancePerSideInches)} clearance/side`;
    badge.className = 'status-fits';
  } else {
    badge.textContent = `COLLISION: ${fmtInches(-clearancePerSideInches)}/side deficit`;
    badge.className = 'status-collision';
  }

  const totalH = riserFt + cfg.shellHeight;
  document.getElementById('total-height-value').textContent = fmtFtIn(totalH);
}

// ============================================================
// RISER SNAP MARKS
// ============================================================
function updateRiserSnaps() {
  const cfg = DOME_CONFIGS[currentDomeKey];
  const snapContainer = document.getElementById('riser-snaps');
  snapContainer.innerHTML = '';

  let prevPct = -Infinity;
  for (const val of cfg.riserOptions) {
    if (val === 0) continue;
    const pct = (val / 120) * 100;
    const mark = document.createElement('span');
    mark.className = 'snap-mark';
    mark.style.left = pct + '%';
    mark.textContent = val + '"';
    // Offset vertically if too close to previous mark to avoid overlap
    if (pct - prevPct < 8) {
      mark.style.top = '10px';
    }
    prevPct = pct;
    mark.addEventListener('click', () => {
      riserHeightInches = val;
      document.getElementById('riser-slider').value = val;
      document.getElementById('riser-value').textContent = val + '"';
      rebuildScene();
    });
    snapContainer.appendChild(mark);
  }
}

// ============================================================
// CAMERA PRESETS
// ============================================================
function setCameraPreset(preset) {
  const cfg = DOME_CONFIGS[currentDomeKey];
  const riserFt = riserHeightInches / 12;
  const midH = (riserFt + cfg.shellHeight) / 2;
  const dist = cfg.diameter * 1.5;

  orbitControls.target.set(0, midH, 0);

  switch (preset) {
    case 'front':
      camera.position.set(0, midH, dist);
      break;
    case 'side':
      camera.position.set(dist, midH, 0);
      break;
    case 'top':
      camera.position.set(0, dist * 1.2, 0.1);
      orbitControls.target.set(0, 0, 0);
      break;
    case 'quarter':
      camera.position.set(dist * 0.6, midH + 10, dist * 0.75);
      break;
    case 'drawing':
      // Top-down view matching the hand-drawn floor plan
      camera.position.set(0, dist * 1.8, 5);
      orbitControls.target.set(0, 0, 0);
      break;
    case 'entry':
      camera.position.set(0, 6, cfg.baseRadius + 15);
      orbitControls.target.set(0, 6, cfg.baseRadius);
      break;
    case 'canopy-top':
      camera.position.set(0.1, 30, 0.1);
      orbitControls.target.set(0, 0, cfg.baseRadius * 0.5);
      break;
    case 'bird':
      camera.position.set(dist * 0.4, dist * 1.0, dist * 0.4);
      orbitControls.target.set(0, 0, 0);
      break;
  }

  orbitControls.update();
}

window.setCameraPreset = setCameraPreset;

// ============================================================
// EVENT LISTENERS
// ============================================================
document.getElementById('dome-select').addEventListener('change', (e) => {
  currentDomeKey = e.target.value;
  // Set riser to NSD default for this model
  const cfg = DOME_CONFIGS[currentDomeKey];
  if (cfg && cfg.defaultRiserIn !== undefined) {
    riserHeightInches = cfg.defaultRiserIn;
    document.getElementById('riser-slider').value = riserHeightInches;
    document.getElementById('riser-value').textContent = riserHeightInches + '"';
  }
  updateRiserSnaps();
  rebuildScene();
});

document.getElementById('octagonal-base').addEventListener('change', (e) => {
  octagonalBase = e.target.checked;
  rebuildScene();
});

/* Profile slider removed — profile is fixed per NSD model
document.getElementById('profile-slider').addEventListener('input', (e) => {
  domeProfileRatio = parseFloat(e.target.value) / 100;
  document.getElementById('profile-value').textContent = e.target.value + '%';
  updateDomeProfile();
  rebuildScene();
});
*/

document.getElementById('riser-slider').addEventListener('input', (e) => {
  riserHeightInches = parseFloat(e.target.value);
  document.getElementById('riser-value').textContent = riserHeightInches + '"';
  rebuildScene();
});

document.getElementById('wing-hnl-slider').addEventListener('input', (e) => {
  wingHNL = parseFloat(e.target.value);
  document.getElementById('wing-hnl-value').textContent = fmtFtIn(wingHNL);
  rebuildScene();
});

document.getElementById('wing-hnr-slider').addEventListener('input', (e) => {
  wingHNR = parseFloat(e.target.value);
  document.getElementById('wing-hnr-value').textContent = fmtFtIn(wingHNR);
  rebuildScene();
});

document.getElementById('wing-hfl-slider').addEventListener('input', (e) => {
  wingHFL = parseFloat(e.target.value);
  document.getElementById('wing-hfl-value').textContent = fmtFtIn(wingHFL);
  rebuildScene();
});

document.getElementById('wing-hfr-slider').addEventListener('input', (e) => {
  wingHFR = parseFloat(e.target.value);
  document.getElementById('wing-hfr-value').textContent = fmtFtIn(wingHFR);
  rebuildScene();
});

document.getElementById('roof-overhang-slider').addEventListener('input', (e) => {
  roofOverhangFt = parseFloat(e.target.value);
  document.getElementById('roof-overhang-value').textContent = fmtFtIn(roofOverhangFt);
  rebuildScene();
});

document.getElementById('wing-width-slider').addEventListener('input', (e) => {
  wingWidthFt = parseFloat(e.target.value);
  document.getElementById('wing-width-value').textContent = fmtFtIn(wingWidthFt);
  rebuildScene();
});

document.getElementById('wing-angle-slider').addEventListener('input', (e) => {
  wingAngleDeg = parseFloat(e.target.value);
  document.getElementById('wing-angle-value').innerHTML = wingAngleDeg + '&deg;';
  rebuildScene();
});

document.getElementById('wing-depth-slider').addEventListener('input', (e) => {
  wingDepthFt = parseFloat(e.target.value);
  document.getElementById('wing-depth-value').textContent = fmtFtIn(wingDepthFt);
  rebuildScene();
});

document.getElementById('wing-arc-slider').addEventListener('input', (e) => {
  wingArcDiameter = parseFloat(e.target.value);
  document.getElementById('wing-arc-value').textContent = wingArcDiameter === 0 ? 'Dome' : fmtFtIn(wingArcDiameter);
  rebuildScene();
});

document.getElementById('canopy-depth-slider').addEventListener('input', (e) => {
  canopyDepthFt = parseFloat(e.target.value);
  document.getElementById('canopy-depth-value').textContent = fmtFtIn(canopyDepthFt);
  rebuildScene();
});

document.getElementById('show-canopy').addEventListener('change', (e) => {
  showCanopy = e.target.checked;
  rebuildScene();
});

document.getElementById('entry-width-slider').addEventListener('input', (e) => {
  entryWidth = parseFloat(e.target.value);
  document.getElementById('entry-width-value').textContent = fmtFtIn(entryWidth);
  rebuildScene();
});

document.getElementById('entry-depth-slider').addEventListener('input', (e) => {
  entryDepth = parseFloat(e.target.value);
  document.getElementById('entry-depth-value').textContent = fmtFtIn(entryDepth);
  rebuildScene();
});

document.getElementById('entry-roof-select').addEventListener('change', (e) => {
  entryRoofStyle = e.target.value;
  document.getElementById('entry-roof-value').textContent = e.target.options[e.target.selectedIndex].text;
  rebuildScene();
});

document.getElementById('connect-wings-to-entry').addEventListener('change', (e) => {
  connectWingsToEntry = e.target.checked;
  rebuildScene();
});

document.getElementById('show-wings').addEventListener('change', (e) => {
  showWings = e.target.checked;
  rebuildScene();
});

document.getElementById('show-wireframe').addEventListener('change', (e) => {
  showWireframe = e.target.checked;
  domeGroup.children.forEach(c => {
    if (c.isLineSegments && c.material === domeWireMaterial) c.visible = showWireframe;
  });
});

document.getElementById('show-markers').addEventListener('change', (e) => {
  showMarkers = e.target.checked;
  rebuildScene();
});

document.getElementById('show-vertex-labels').addEventListener('change', (e) => {
  showVertexLabels = e.target.checked;
  rebuildScene();
});

document.getElementById('show-width-ring').addEventListener('change', (e) => {
  showWidthRing = e.target.checked;
  rebuildScene();
});

document.getElementById('show-grid').addEventListener('change', (e) => {
  showGrid = e.target.checked;
  if (gridHelper) gridHelper.visible = showGrid;
});

document.getElementById('show-dimensions').addEventListener('change', (e) => {
  showDimensions = e.target.checked;
  rebuildScene();
});

document.getElementById('show-interior').addEventListener('change', (e) => {
  showInterior = e.target.checked;
  domeMaterial.opacity = showInterior ? Math.min(domeOpacity, 0.3) : domeOpacity;
  rebuildScene();
});

document.getElementById('show-room-labels').addEventListener('change', (e) => {
  showRoomLabels = e.target.checked;
  rebuildScene();
});

document.getElementById('cutaway-mode').addEventListener('change', (e) => {
  cutawayMode = e.target.checked;
  rebuildScene();
});

document.getElementById('outdoor-env').addEventListener('change', (e) => {
  outdoorEnv = e.target.checked;
  setupEnvironment();
  rebuildScene();
});

document.getElementById('opacity-slider').addEventListener('input', (e) => {
  domeOpacity = parseFloat(e.target.value) / 100;
  document.getElementById('opacity-value').textContent = e.target.value + '%';
  domeMaterial.opacity = domeOpacity;
  domeMaterial.transparent = domeOpacity < 0.95;
  domeMaterial.depthWrite = domeOpacity >= 0.95;
});

document.getElementById('edit-mode').addEventListener('change', (e) => {
  editMode = e.target.checked;
  handleGroup.visible = editMode;
  if (!editMode) {
    endDrag();
    document.body.classList.remove('cursor-grab');
  }
  rebuildScene();
});

document.getElementById('draw-rooms').addEventListener('change', (e) => {
  drawRoomsMode = e.target.checked;
  if (drawRoomsMode) {
    document.body.classList.add('cursor-crosshair');
  } else {
    document.body.classList.remove('cursor-crosshair');
    // Cancel any in-progress wall drawing
    drawingWall = null;
    if (drawPreviewLine) {
      scene.remove(drawPreviewLine);
      drawPreviewLine.geometry.dispose();
      drawPreviewLine = null;
    }
  }
  rebuildCustomWalls();
});

document.getElementById('walk-mode').addEventListener('change', (e) => {
  walkMode = e.target.checked;
  document.getElementById('camera-view-row').style.display = walkMode ? '' : 'none';
  orbitControls.enabled = !walkMode;

  if (walkMode) {
    if (!turtleGroup) {
      turtleGroup = buildTurtle();
      scene.add(turtleGroup);
    }
    turtleGroup.visible = !firstPersonView;
    turtleGroup.position.set(0, 0, 0);
    turtleDirection = 0;
    turtleBody.rotation.y = 0;
    // Initialize camera yaw from current camera position
    camYaw = Math.atan2(camera.position.x, camera.position.z);
    camPitch = -0.3;
    Object.keys(keysPressed).forEach(k => keysPressed[k] = false);
  } else {
    if (turtleGroup) turtleGroup.visible = false;
    // Exit pointer lock if active
    if (document.pointerLockElement) document.exitPointerLock();
    setCameraPreset('quarter');
  }
});

document.getElementById('first-person').addEventListener('change', (e) => {
  firstPersonView = e.target.checked;
  if (turtleGroup) turtleGroup.visible = !firstPersonView;
});

document.getElementById('ortho-camera').addEventListener('change', (e) => {
  setOrthoMode(e.target.checked);
});

// ============================================================
// WINDOW RESIZE
// ============================================================
window.addEventListener('resize', () => {
  const aspect = window.innerWidth / window.innerHeight;
  perspCamera.aspect = aspect;
  perspCamera.updateProjectionMatrix();
  if (useOrthoCamera) syncOrthoFrustum();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============================================================
// WALK MODE: TURTLE CHARACTER + MOVEMENT + CAMERA
// ============================================================
let turtleGroup = null;
let turtleBody = null;
let turtleDirection = 0;
let turtleWalkCycle = 0;
const TURTLE_SPEED = 0.3;
const TURTLE_FLY_SPEED = 0.2;
const TURTLE_SCALE = 3.0;
const TURTLE_EYE_HEIGHT = 4.0;
const MOUSE_SENSITIVITY = 0.002;

// Camera angles (yaw = horizontal, pitch = vertical)
let camYaw = 0;
let camPitch = -0.3; // slight downward look
let camDist = 14; // third-person distance
const CAM_PITCH_MIN = -Math.PI / 2 + 0.1;
const CAM_PITCH_MAX = Math.PI / 2 - 0.1;
const CAM_DIST_MIN = 4;
const CAM_DIST_MAX = 40;

const keysPressed = {};
window.addEventListener('keydown', (e) => {
  if (!walkMode) return;
  keysPressed[e.key.toLowerCase()] = true;
  // Prevent space from scrolling page
  if (e.key === ' ') e.preventDefault();
});
window.addEventListener('keyup', (e) => {
  keysPressed[e.key.toLowerCase()] = false;
});

// Pointer lock for mouse look
function requestPointerLock() {
  if (walkMode && !document.pointerLockElement) {
    renderer.domElement.requestPointerLock();
  }
}

renderer.domElement.addEventListener('click', () => {
  if (walkMode) requestPointerLock();
});

document.addEventListener('mousemove', (e) => {
  if (!walkMode || document.pointerLockElement !== renderer.domElement) return;
  camYaw -= e.movementX * MOUSE_SENSITIVITY;
  camPitch -= e.movementY * MOUSE_SENSITIVITY;
  camPitch = Math.max(CAM_PITCH_MIN, Math.min(CAM_PITCH_MAX, camPitch));
});

// Scroll wheel — wall thickness in draw-rooms mode, camera distance in walk mode
renderer.domElement.addEventListener('wheel', (e) => {
  // In draw-rooms mode, scroll on a hovered wall adjusts thickness
  if (drawRoomsMode && hoveredWallMesh && hoveredWallMesh.userData.customWallIndex !== undefined) {
    e.preventDefault();
    const w = customWalls[hoveredWallMesh.userData.customWallIndex];
    if (w) {
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      w.thickness = Math.max(0.1, Math.min(2.0, (w.thickness || 0.5) + delta));
      rebuildCustomWalls();
    }
    return;
  }
  if (!walkMode) return;
  e.preventDefault();
  camDist += e.deltaY * 0.02;
  camDist = Math.max(CAM_DIST_MIN, Math.min(CAM_DIST_MAX, camDist));
}, { passive: false });

function buildTurtle() {
  const group = new THREE.Group();
  const body = new THREE.Group();
  group.add(body);

  // Lower shell (plastron)
  const lowerGeo = new THREE.SphereGeometry(1, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
  lowerGeo.scale(1, 0.3, 1.2);
  const lowerMat = new THREE.MeshLambertMaterial({ color: 0xEDC9AF });
  const lower = new THREE.Mesh(lowerGeo, lowerMat);
  lower.rotation.x = Math.PI;
  lower.position.y = 0.3;
  lower.castShadow = true;
  body.add(lower);

  // Upper shell (carapace)
  const upperGeo = new THREE.SphereGeometry(1, 16, 12);
  upperGeo.scale(1.1, 0.5, 1.2);
  const upperMat = new THREE.MeshLambertMaterial({ color: 0x2E8B57 });
  const upper = new THREE.Mesh(upperGeo, upperMat);
  upper.position.y = 0.6;
  upper.castShadow = true;
  body.add(upper);

  // Shell pattern wireframe
  const patGeo = new THREE.SphereGeometry(1.01, 6, 6);
  patGeo.scale(1.1, 0.5, 1.2);
  const patMat = new THREE.MeshBasicMaterial({ color: 0x8B4513, wireframe: true });
  const pattern = new THREE.Mesh(patGeo, patMat);
  pattern.position.y = 0.6;
  body.add(pattern);

  // Head
  const headGroup = new THREE.Group();
  const headGeo = new THREE.SphereGeometry(0.3, 16, 16);
  const headMat = new THREE.MeshLambertMaterial({ color: 0x7D9E74 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.z = 0.3;
  head.castShadow = true;
  headGroup.add(head);

  // Eyes
  for (const x of [0.1, -0.1]) {
    const eyeGeo = new THREE.SphereGeometry(0.09, 8, 8);
    const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
    const eye = new THREE.Mesh(eyeGeo, eyeMat);
    eye.position.set(x, 0.05, 0.5);
    headGroup.add(eye);
    const whiteGeo = new THREE.SphereGeometry(0.04, 8, 8);
    const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
    const white = new THREE.Mesh(whiteGeo, whiteMat);
    white.position.set(x + 0.02, 0.07, 0.53);
    headGroup.add(white);
  }

  // Smile
  const smileGeo = new THREE.TorusGeometry(0.1, 0.02, 8, 8, Math.PI);
  const smileMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
  const smile = new THREE.Mesh(smileGeo, smileMat);
  smile.position.set(0, -0.05, 0.5);
  smile.rotation.set(0, 0, Math.PI);
  headGroup.add(smile);

  headGroup.position.set(0, 0.65, 1);
  body.add(headGroup);

  // Legs
  function makeLeg(x, z) {
    const legGrp = new THREE.Group();
    legGrp.isLeg = true;
    const legGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.5, 8);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x7D9E74 });
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.rotation.x = Math.PI / 2;
    leg.position.y = -0.2;
    leg.castShadow = true;
    const footGeo = new THREE.SphereGeometry(0.2, 8, 8);
    const footMat = new THREE.MeshLambertMaterial({ color: 0x5D7E54 });
    const foot = new THREE.Mesh(footGeo, footMat);
    foot.position.z = 0.3;
    foot.castShadow = true;
    legGrp.add(leg);
    legGrp.add(foot);
    legGrp.position.set(x, 0.3, z);
    return legGrp;
  }
  body.add(makeLeg(0.8, 0.8));
  body.add(makeLeg(-0.8, 0.8));
  body.add(makeLeg(0.8, -0.8));
  body.add(makeLeg(-0.8, -0.8));

  // Tail
  const tailGeo = new THREE.ConeGeometry(0.15, 0.4, 8);
  const tailMat = new THREE.MeshLambertMaterial({ color: 0x7D9E74 });
  const tail = new THREE.Mesh(tailGeo, tailMat);
  tail.position.set(0, 0.45, -1.25);
  tail.rotation.x = -Math.PI / 2;
  tail.castShadow = true;
  body.add(tail);

  // Scale the whole group
  group.scale.set(TURTLE_SCALE, TURTLE_SCALE, TURTLE_SCALE);

  turtleBody = body;
  return group;
}

function updateTurtleAnimation(moving) {
  if (!turtleBody) return;
  if (moving) {
    turtleBody.children.forEach(child => {
      if (child.isLeg) {
        child.position.y = 0.3 + Math.sin(turtleWalkCycle * 2) * 0.05;
      }
    });
  } else {
    turtleBody.children.forEach(child => {
      if (child.isLeg) {
        child.position.y = 0.3;
      }
    });
  }
}

function updateTurtleMovement() {
  if (!walkMode || !turtleGroup) return;

  // Forward direction from camera yaw (flattened to XZ)
  const forward = new THREE.Vector3(-Math.sin(camYaw), 0, -Math.cos(camYaw));
  const right = new THREE.Vector3(forward.z, 0, -forward.x);
  const strafeScale = firstPersonView ? 0.35 : 1.0;

  let moveX = 0, moveY = 0, moveZ = 0;
  let movingXZ = false;

  if (keysPressed['w'] || keysPressed['arrowup']) {
    moveX += forward.x * TURTLE_SPEED;
    moveZ += forward.z * TURTLE_SPEED;
    movingXZ = true;
  }
  if (keysPressed['s'] || keysPressed['arrowdown']) {
    moveX -= forward.x * TURTLE_SPEED;
    moveZ -= forward.z * TURTLE_SPEED;
    movingXZ = true;
  }
  if (keysPressed['a'] || keysPressed['arrowleft']) {
    moveX -= right.x * TURTLE_SPEED * strafeScale;
    moveZ -= right.z * TURTLE_SPEED * strafeScale;
    movingXZ = true;
  }
  if (keysPressed['d'] || keysPressed['arrowright']) {
    moveX += right.x * TURTLE_SPEED * strafeScale;
    moveZ += right.z * TURTLE_SPEED * strafeScale;
    movingXZ = true;
  }

  // Fly up/down (Space / Shift)
  if (keysPressed[' ']) {
    moveY += TURTLE_FLY_SPEED;
  }
  if (keysPressed['shift']) {
    moveY -= TURTLE_FLY_SPEED;
  }

  const moving = movingXZ || moveY !== 0;

  if (moving) {
    turtleGroup.position.x += moveX;
    turtleGroup.position.y = Math.max(0, turtleGroup.position.y + moveY);
    turtleGroup.position.z += moveZ;
  }

  // Rotate turtle body toward XZ movement direction (smooth)
  if (movingXZ) {
    const targetDir = Math.atan2(moveX, moveZ);
    let angleDiff = targetDir - turtleDirection;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    turtleDirection += angleDiff * 0.12;
    turtleBody.rotation.y = turtleDirection;
    turtleWalkCycle += 0.15;
  }

  updateTurtleAnimation(movingXZ);
}

function updateWalkCamera() {
  if (!walkMode || !turtleGroup) return;

  const tPos = turtleGroup.position;

  if (firstPersonView) {
    // First person: camera at eye height offset, looking where mouse points
    const eyeY = tPos.y + TURTLE_EYE_HEIGHT;
    camera.position.set(tPos.x, eyeY, tPos.z);

    const lookX = tPos.x - Math.sin(camYaw) * Math.cos(camPitch);
    const lookY = eyeY + Math.sin(camPitch);
    const lookZ = tPos.z - Math.cos(camYaw) * Math.cos(camPitch);
    camera.lookAt(lookX, lookY, lookZ);

    turtleGroup.visible = false;
  } else {
    // Third person: spherical offset from turtle using yaw/pitch/distance
    const offX = Math.sin(camYaw) * Math.cos(camPitch) * camDist;
    const offY = -Math.sin(camPitch) * camDist;
    const offZ = Math.cos(camYaw) * Math.cos(camPitch) * camDist;

    const targetCamPos = new THREE.Vector3(
      tPos.x + offX,
      tPos.y + 2 + Math.max(offY, 1), // keep camera above ground
      tPos.z + offZ
    );

    camera.position.lerp(targetCamPos, 0.12);
    camera.lookAt(tPos.x, tPos.y + 2, tPos.z);
    turtleGroup.visible = true;
  }
}

// ============================================================
// ORTHOGRAPHIC CAMERA TOGGLE
// ============================================================
function syncOrthoFrustum() {
  const dist = perspCamera.position.distanceTo(orbitControls.target);
  const halfH = dist * Math.tan(perspCamera.fov * Math.PI / 360);
  const aspect = window.innerWidth / window.innerHeight;
  const halfW = halfH * aspect;
  orthoCamera.left = -halfW;
  orthoCamera.right = halfW;
  orthoCamera.top = halfH;
  orthoCamera.bottom = -halfH;
  orthoCamera.updateProjectionMatrix();
}

function setOrthoMode(enabled) {
  useOrthoCamera = enabled;
  if (enabled) {
    // Copy position/rotation from perspective camera
    orthoCamera.position.copy(perspCamera.position);
    orthoCamera.quaternion.copy(perspCamera.quaternion);
    syncOrthoFrustum();
    camera = orthoCamera;
  } else {
    // Copy position back to perspective camera
    perspCamera.position.copy(orthoCamera.position);
    perspCamera.quaternion.copy(orthoCamera.quaternion);
    camera = perspCamera;
  }
  orbitControls.object = camera;
  orbitControls.update();
}

// ============================================================
// ANIMATION LOOP
// ============================================================
function animate() {
  requestAnimationFrame(animate);
  if (walkMode) {
    updateTurtleMovement();
    updateWalkCamera();
  } else {
    orbitControls.update();
    if (useOrthoCamera) syncOrthoFrustum();
  }
  renderer.render(scene, camera);
  if (window._updateRefTransform) window._updateRefTransform();
}

// ============================================================
// SAVE / LOAD STATE
// ============================================================
function getState() {
  return {
    version: 1,
    dome: {
      key: currentDomeKey,
      // profileRatio removed — fixed per NSD model
      octagonalBase,
      octSideFractions: [...octSideFractions],
      riserHeightInches,
    },
    wings: {
      show: showWings,
      hNL: wingHNL,
      hNR: wingHNR,
      hFL: wingHFL,
      hFR: wingHFR,
      width: wingWidthFt,
      depth: wingDepthFt,
      angle: wingAngleDeg,
      arcDiameter: wingArcDiameter,
      roofOverhang: roofOverhangFt,
      canopyDepth: canopyDepthFt,
      showCanopy,
      entryWidth,
      entryDepth,
      entryRoofStyle,
      connectWingsToEntry,
    },
    display: {
      wireframe: showWireframe,
      markers: showMarkers,
      vertexLabels: showVertexLabels,
      widthRing: showWidthRing,
      grid: showGrid,
      dimensions: showDimensions,
      interior: showInterior,
      roomLabels: showRoomLabels,
      cutaway: cutawayMode,
      outdoorEnv,
      domeOpacity,
    },
    edit: {
      editMode,
      drawRoomsMode,
    },
    walk: {
      walkMode,
      firstPersonView,
      turtlePos: turtleGroup ? { x: turtleGroup.position.x, y: turtleGroup.position.y, z: turtleGroup.position.z } : null,
      turtleDirection,
      camYaw,
      camPitch,
      camDist,
    },
    refOverlay: (() => {
      const img = document.getElementById('ref-overlay-img');
      if (!img.src || img.style.display === 'none') return null;
      // Convert image to data URL for portable save
      try {
        const c = document.createElement('canvas');
        c.width = img.naturalWidth; c.height = img.naturalHeight;
        c.getContext('2d').drawImage(img, 0, 0);
        return {
          dataUrl: c.toDataURL('image/jpeg', 0.8),
          opacity: parseFloat(document.getElementById('ref-overlay-opacity').value),
          scale: parseFloat(document.getElementById('ref-overlay-scale').value),
          offsetX: window._refOverlay ? window._refOverlay.offsetX : 0,
          offsetY: window._refOverlay ? window._refOverlay.offsetY : 0,
        };
      } catch (e) { return null; }
    })(),
    customWalls: customWalls.map(w => ({ ...w })),
  };
}

function exportState() {
  const state = getState();
  const json = JSON.stringify(state, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const cfg = DOME_CONFIGS[currentDomeKey];
  a.download = `dome-${cfg.label}-${new Date().toISOString().slice(0,10)}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function importState(state) {
  if (!state || !state.version) return;

  // Dome
  if (state.dome) {
    currentDomeKey = state.dome.key || '33H';
    // Handle old save files with keys like '33', '36', '40'
    if (!DOME_CONFIGS[currentDomeKey]) {
      const legacyMap = { '33': '36H', '36': '36H', '40': '40H' };
      currentDomeKey = legacyMap[currentDomeKey] || '36H';
    }
    document.getElementById('dome-select').value = currentDomeKey;
    // profileRatio removed — fixed per NSD model
    octagonalBase = state.dome.octagonalBase ?? false;
    document.getElementById('octagonal-base').checked = octagonalBase;
    if (state.dome.octSideFractions) octSideFractions = [...state.dome.octSideFractions];
    riserHeightInches = state.dome.riserHeightInches ?? 28;
    document.getElementById('riser-slider').value = riserHeightInches;
    document.getElementById('riser-value').textContent = riserHeightInches + '"';
  }

  // Wings
  if (state.wings) {
    showWings = state.wings.show ?? true;
    document.getElementById('show-wings').checked = showWings;
    wingHNL = state.wings.hNL ?? 20;
    wingHNR = state.wings.hNR ?? 20;
    wingHFL = state.wings.hFL ?? 12;
    wingHFR = state.wings.hFR ?? 12;
    wingWidthFt = state.wings.width ?? 16;
    wingDepthFt = state.wings.depth ?? 24;
    wingAngleDeg = state.wings.angle ?? 25;
    wingArcDiameter = state.wings.arcDiameter ?? 100;
    roofOverhangFt = state.wings.roofOverhang ?? 1;

    document.getElementById('wing-hnl-slider').value = wingHNL;
    document.getElementById('wing-hnl-value').textContent = fmtFtIn(wingHNL);
    document.getElementById('wing-hnr-slider').value = wingHNR;
    document.getElementById('wing-hnr-value').textContent = fmtFtIn(wingHNR);
    document.getElementById('wing-hfl-slider').value = wingHFL;
    document.getElementById('wing-hfl-value').textContent = fmtFtIn(wingHFL);
    document.getElementById('wing-hfr-slider').value = wingHFR;
    document.getElementById('wing-hfr-value').textContent = fmtFtIn(wingHFR);
    document.getElementById('wing-width-slider').value = wingWidthFt;
    document.getElementById('wing-width-value').textContent = fmtFtIn(wingWidthFt);
    document.getElementById('wing-depth-slider').value = wingDepthFt;
    document.getElementById('wing-depth-value').textContent = fmtFtIn(wingDepthFt);
    document.getElementById('wing-angle-slider').value = wingAngleDeg;
    document.getElementById('wing-angle-value').innerHTML = wingAngleDeg + '&deg;';
    document.getElementById('wing-arc-slider').value = wingArcDiameter;
    document.getElementById('wing-arc-value').textContent = wingArcDiameter === 0 ? 'Dome' : fmtFtIn(wingArcDiameter);
    document.getElementById('roof-overhang-slider').value = roofOverhangFt;
    document.getElementById('roof-overhang-value').textContent = fmtFtIn(roofOverhangFt);
    canopyDepthFt = state.wings.canopyDepth ?? 6;
    document.getElementById('canopy-depth-slider').value = canopyDepthFt;
    document.getElementById('canopy-depth-value').textContent = fmtFtIn(canopyDepthFt);
    showCanopy = state.wings.showCanopy ?? false;
    document.getElementById('show-canopy').checked = showCanopy;
    entryWidth = state.wings.entryWidth ?? (state.wings.entryGap ?? 8);
    document.getElementById('entry-width-slider').value = entryWidth;
    document.getElementById('entry-width-value').textContent = fmtFtIn(entryWidth);
    entryDepth = state.wings.entryDepth ?? 5;
    document.getElementById('entry-depth-slider').value = entryDepth;
    document.getElementById('entry-depth-value').textContent = fmtFtIn(entryDepth);
    entryRoofStyle = state.wings.entryRoofStyle ?? 'flat';
    document.getElementById('entry-roof-select').value = entryRoofStyle;
    const roofOpt = document.getElementById('entry-roof-select');
    document.getElementById('entry-roof-value').textContent = roofOpt.options[roofOpt.selectedIndex].text;
    connectWingsToEntry = state.wings.connectWingsToEntry ?? false;
    document.getElementById('connect-wings-to-entry').checked = connectWingsToEntry;
  }

  // Display
  if (state.display) {
    showWireframe = state.display.wireframe ?? true;
    document.getElementById('show-wireframe').checked = showWireframe;
    showMarkers = state.display.markers ?? true;
    document.getElementById('show-markers').checked = showMarkers;
    showVertexLabels = state.display.vertexLabels ?? true;
    document.getElementById('show-vertex-labels').checked = showVertexLabels;
    showWidthRing = state.display.widthRing ?? true;
    document.getElementById('show-width-ring').checked = showWidthRing;
    showGrid = state.display.grid ?? false;
    document.getElementById('show-grid').checked = showGrid;
    showDimensions = state.display.dimensions ?? false;
    document.getElementById('show-dimensions').checked = showDimensions;
    showInterior = state.display.interior ?? true;
    document.getElementById('show-interior').checked = showInterior;
    showRoomLabels = state.display.roomLabels ?? true;
    document.getElementById('show-room-labels').checked = showRoomLabels;
    cutawayMode = state.display.cutaway ?? false;
    document.getElementById('cutaway-mode').checked = cutawayMode;
    outdoorEnv = state.display.outdoorEnv ?? true;
    document.getElementById('outdoor-env').checked = outdoorEnv;
    domeOpacity = state.display.domeOpacity ?? 0.7;
    document.getElementById('opacity-slider').value = Math.round(domeOpacity * 100);
    document.getElementById('opacity-value').textContent = Math.round(domeOpacity * 100) + '%';
    domeMaterial.opacity = domeOpacity;
    domeMaterial.transparent = domeOpacity < 0.95;
    domeMaterial.depthWrite = domeOpacity >= 0.95;
  }

  // Edit
  if (state.edit) {
    editMode = state.edit.editMode ?? false;
    document.getElementById('edit-mode').checked = editMode;
    handleGroup.visible = editMode;
    drawRoomsMode = state.edit.drawRoomsMode ?? false;
    document.getElementById('draw-rooms').checked = drawRoomsMode;
    if (drawRoomsMode) document.body.classList.add('cursor-crosshair');
    else document.body.classList.remove('cursor-crosshair');
  }

  // Reference overlay
  if (state.refOverlay) {
    const img = document.getElementById('ref-overlay-img');
    img.src = state.refOverlay.dataUrl;
    img.style.display = 'block';
    img.style.pointerEvents = 'auto';
    const opacity = state.refOverlay.opacity ?? 50;
    const scale = state.refOverlay.scale ?? 100;
    img.style.opacity = opacity / 100;
    document.getElementById('ref-overlay-opacity').value = opacity;
    document.getElementById('ref-overlay-opacity-value').textContent = opacity + '%';
    document.getElementById('ref-overlay-scale').value = scale;
    document.getElementById('ref-overlay-scale-value').textContent = scale + '%';
    if (window._refOverlay) {
      window._refOverlay.offsetX = state.refOverlay.offsetX ?? 0;
      window._refOverlay.offsetY = state.refOverlay.offsetY ?? 0;
    }
  } else {
    const img = document.getElementById('ref-overlay-img');
    img.style.display = 'none';
    img.src = '';
  }

  // Custom walls
  if (state.customWalls) {
    customWalls = state.customWalls.map(w => ({ ...w }));
  }

  // Walk mode
  if (state.walk) {
    firstPersonView = state.walk.firstPersonView ?? false;
    document.getElementById('first-person').checked = firstPersonView;
    camYaw = state.walk.camYaw ?? 0;
    camPitch = state.walk.camPitch ?? -0.3;
    camDist = state.walk.camDist ?? 14;
    turtleDirection = state.walk.turtleDirection ?? 0;

    walkMode = state.walk.walkMode ?? false;
    document.getElementById('walk-mode').checked = walkMode;
    document.getElementById('camera-view-row').style.display = walkMode ? '' : 'none';
    orbitControls.enabled = !walkMode;

    if (walkMode) {
      if (!turtleGroup) {
        turtleGroup = buildTurtle();
        scene.add(turtleGroup);
      }
      turtleGroup.visible = !firstPersonView;
      if (state.walk.turtlePos) {
        turtleGroup.position.set(state.walk.turtlePos.x, state.walk.turtlePos.y, state.walk.turtlePos.z);
      }
      turtleBody.rotation.y = turtleDirection;
      Object.keys(keysPressed).forEach(k => keysPressed[k] = false);
    } else {
      if (turtleGroup) turtleGroup.visible = false;
    }
  }

  // Rebuild everything
  setupEnvironment();
  updateRiserSnaps();
  rebuildScene();
  if (!walkMode) setCameraPreset('quarter');
}

document.getElementById('export-state').addEventListener('click', exportState);

document.getElementById('import-state').addEventListener('click', () => {
  document.getElementById('import-file').click();
});

document.getElementById('import-file').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (evt) => {
    try {
      const state = JSON.parse(evt.target.result);
      importState(state);
    } catch (err) {
      console.error('Failed to load state:', err);
    }
  };
  reader.readAsText(file);
  // Reset so the same file can be loaded again
  e.target.value = '';
});

// ============================================================
// SCREENSHOT MODE
// ============================================================
let screenshotMode = false;
let screenshotSavedState = null;

function enterScreenshotMode() {
  if (screenshotMode) return;
  screenshotMode = true;

  // Save all display state that screenshot mode overrides
  screenshotSavedState = {
    showWireframe, showMarkers, showVertexLabels, showWidthRing,
    showDimensions, showGrid, domeOpacity,
    handleGroupVisible: handleGroup.visible,
    octHandleGroupVisible: octHandleGroup.visible,
  };

  // Hide HTML UI
  document.getElementById('title-bar').style.display = 'none';
  document.getElementById('controls').style.display = 'none';
  document.getElementById('info-panel').style.display = 'none';

  // Override display state for clean rendering
  showWireframe = false;
  showMarkers = false;
  showVertexLabels = false;
  showWidthRing = false;
  showDimensions = false;
  showGrid = false;
  domeOpacity = 1.0;
  domeMaterial.opacity = 1.0;
  domeMaterial.transparent = false;
  domeMaterial.depthWrite = true;

  // Hide non-rebuilt groups
  handleGroup.visible = false;
  octHandleGroup.visible = false;

  // Single rebuild with clean state
  rebuildScene();
  if (gridHelper) gridHelper.visible = false;
}

function exitScreenshotMode() {
  if (!screenshotMode) return;
  screenshotMode = false;

  // Restore HTML UI
  document.getElementById('title-bar').style.display = '';
  document.getElementById('controls').style.display = '';
  document.getElementById('info-panel').style.display = '';

  // Restore all display state
  if (screenshotSavedState) {
    showWireframe = screenshotSavedState.showWireframe;
    showMarkers = screenshotSavedState.showMarkers;
    showVertexLabels = screenshotSavedState.showVertexLabels;
    showWidthRing = screenshotSavedState.showWidthRing;
    showDimensions = screenshotSavedState.showDimensions;
    showGrid = screenshotSavedState.showGrid;
    domeOpacity = screenshotSavedState.domeOpacity;
    domeMaterial.opacity = domeOpacity;
    domeMaterial.transparent = domeOpacity < 0.95;
    domeMaterial.depthWrite = domeOpacity >= 0.95;
    handleGroup.visible = screenshotSavedState.handleGroupVisible;
    octHandleGroup.visible = screenshotSavedState.octHandleGroupVisible;
    screenshotSavedState = null;

    // Single rebuild to restore everything
    rebuildScene();
    if (gridHelper) gridHelper.visible = showGrid;
  }
}

document.getElementById('screenshot-mode-btn').addEventListener('click', enterScreenshotMode);

window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && screenshotMode) {
    exitScreenshotMode();
    e.preventDefault();
  }
});

// ============================================================
// REFERENCE IMAGE OVERLAY
// ============================================================
{
  const refImg = document.getElementById('ref-overlay-img');
  const refFileInput = document.getElementById('ref-overlay-file');
  let refOffsetX = 0, refOffsetY = 0, refDragging = false, refDragStartX = 0, refDragStartY = 0;

  document.getElementById('ref-overlay-load').addEventListener('click', () => refFileInput.click());

  refFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    refImg.src = url;
    refImg.style.display = 'block';
    refImg.style.pointerEvents = 'auto';
    refOffsetX = 0; refOffsetY = 0;
    updateRefTransform();
  });

  document.getElementById('ref-overlay-clear').addEventListener('click', () => {
    refImg.style.display = 'none';
    refImg.src = '';
    refFileInput.value = '';
  });

  let refLocked = true;
  const lockBtn = document.getElementById('ref-overlay-lock');
  lockBtn.textContent = 'Unlock';
  lockBtn.addEventListener('click', () => {
    refLocked = !refLocked;
    lockBtn.textContent = refLocked ? 'Unlock' : 'Lock';
    refImg.style.pointerEvents = refLocked ? 'none' : 'auto';
  });

  document.getElementById('ref-overlay-opacity').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    refImg.style.opacity = v / 100;
    document.getElementById('ref-overlay-opacity-value').textContent = v + '%';
  });

  document.getElementById('ref-overlay-scale').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('ref-overlay-scale-value').textContent = v + '%';
    updateRefTransform();
  });

  function updateRefTransform() {
    if (refImg.style.display === 'none' || !refImg.src) return;
    const adjustment = parseFloat(document.getElementById('ref-overlay-scale').value) / 100;
    // Drawing measurements (Kasa circle fit + radial refinement on dome arc)
    // center=(1723, 865), radius=775px, diameter=1550px in 4032x3024 image
    const drawingDomeCx = 1723, drawingDomeCy = 865;
    const drawingDomePx = 1550;
    const imgW = refImg.naturalWidth || 4032, imgH = refImg.naturalHeight || 3024;
    // Project dome center and edge to compute screen-space dome diameter
    // Use full 2D distance (not just X) to handle rotated camera orientations
    const canvasRect = renderer.domElement.getBoundingClientRect();
    const vc = new THREE.Vector3(0, 0, 0).project(camera);
    const ve = new THREE.Vector3(16.5, 0, 0).project(camera);
    const csx = (vc.x * 0.5 + 0.5) * canvasRect.width;
    const csy = (-vc.y * 0.5 + 0.5) * canvasRect.height;
    const esx = (ve.x * 0.5 + 0.5) * canvasRect.width;
    const esy = (-ve.y * 0.5 + 0.5) * canvasRect.height;
    const dx = esx - csx, dy = esy - csy;
    const domeRadiusPx = Math.sqrt(dx * dx + dy * dy);
    const domeDiameterPx = domeRadiusPx * 2;
    // Base scale: match drawing dome circle to screen dome circle
    const baseScale = domeDiameterPx / drawingDomePx;
    const scale = baseScale * adjustment;
    // Position: align drawing dome center with projected dome center
    const screenX = canvasRect.left + csx;
    const screenY = canvasRect.top + csy;
    const overlayLeft = screenX + refOffsetX - drawingDomeCx * scale;
    const overlayTop = screenY + refOffsetY - drawingDomeCy * scale;
    refImg.style.left = overlayLeft + 'px';
    refImg.style.top = overlayTop + 'px';
    refImg.style.width = (imgW * scale) + 'px';
    refImg.style.height = (imgH * scale) + 'px';
    refImg.style.transform = '';
  }
  window._updateRefTransform = updateRefTransform;
  window._refOverlay = {
    get offsetX() { return refOffsetX; },
    get offsetY() { return refOffsetY; },
    set offsetX(v) { refOffsetX = v; },
    set offsetY(v) { refOffsetY = v; },
  };

  // Drag to reposition
  refImg.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;
    refDragging = true;
    refDragStartX = e.clientX - refOffsetX;
    refDragStartY = e.clientY - refOffsetY;
    e.preventDefault();
  });

  window.addEventListener('mousemove', (e) => {
    if (!refDragging) return;
    refOffsetX = e.clientX - refDragStartX;
    refOffsetY = e.clientY - refDragStartY;
    updateRefTransform();
  });

  window.addEventListener('mouseup', () => { refDragging = false; });

  // Auto-load default reference image
  const defaultRefImg = 'drawings/floorplan-top.jpg';
  const testImg = new Image();
  testImg.onload = () => {
    refImg.src = defaultRefImg;
    refImg.style.display = 'block';
    refImg.style.pointerEvents = refLocked ? 'none' : 'auto';
    refImg.style.opacity = '0.6';
    refOffsetX = -81;
    refOffsetY = 8;
    document.getElementById('ref-overlay-opacity').value = 60;
    document.getElementById('ref-overlay-opacity-value').textContent = '60%';
    // Scale slider at 100% = auto-fit; 102% = user-calibrated fine adjustment
    document.getElementById('ref-overlay-scale').value = 102;
    document.getElementById('ref-overlay-scale-value').textContent = '102%';
  };
  testImg.src = defaultRefImg;
}

// Undo/Redo keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Ctrl+Z / Cmd+Z = undo
  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
    e.preventDefault();
    const state = undoStack.undo();
    if (state) {
      undoStack._restoring = true;
      importState(state);
      undoStack._restoring = false;
    }
  // Ctrl+Shift+Z / Cmd+Shift+Z or Ctrl+Y / Cmd+Y = redo
  } else if ((e.ctrlKey || e.metaKey) && ((e.key === 'z' && e.shiftKey) || e.key === 'y')) {
    e.preventDefault();
    const state = undoStack.redo();
    if (state) {
      undoStack._restoring = true;
      importState(state);
      undoStack._restoring = false;
    }
  }
});

// Panel toggle buttons
document.getElementById('controls-toggle').addEventListener('click', () => {
  const wrapper = document.getElementById('controls-wrapper');
  const btn = document.getElementById('controls-toggle');
  wrapper.classList.toggle('hidden');
  btn.innerHTML = wrapper.classList.contains('hidden') ? '&rsaquo;' : '&lsaquo;';
  btn.title = wrapper.classList.contains('hidden') ? 'Show controls' : 'Hide controls';
});

document.getElementById('info-panel-toggle').addEventListener('click', () => {
  const wrapper = document.getElementById('info-panel-wrapper');
  const btn = document.getElementById('info-panel-toggle');
  wrapper.classList.toggle('hidden');
  btn.innerHTML = wrapper.classList.contains('hidden') ? '&lsaquo;' : '&rsaquo;';
  btn.title = wrapper.classList.contains('hidden') ? 'Show panel' : 'Hide panel';
});

// ============================================================
// INIT
// ============================================================
setupEnvironment();
updateRiserSnaps();
rebuildScene();
setCameraPreset('top');
if (useOrthoCamera) {
  setOrthoMode(true);
  document.getElementById('ortho-camera').checked = true;
}
animate();

// Seed undo stack with initial state
undoStack.push(getState());

</script>
</body>
</html>
